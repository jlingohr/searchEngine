http://www.cs.dartmouth.edu/~campbell/cs50/artoftesting.html
Depth: 2
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="artoftesting.tex"> 
<meta name="date" content="2014-02-11 22:45:00"> 
<link rel="stylesheet" type="text/css" href="artoftesting.css"> 
</head><body 
>
<h1 class="likepartHead"><a 
 id="x1-1000"></a>CS 50 Software Design and Implementation</h1>
<h1 class="likepartHead"><a 
 id="x1-2000"></a>Lecture 17</h1>
<h1 class="likepartHead"><a 
 id="x1-3000"></a>The Art of Testing (and Writing Good Code)</h1>
<!--l. 21--><p class="noindent" >Edsger Dijkstra once said that testing can demonstrate the presence of bugs but not their absence. That is
good to keep in mind when you are developing code - good code. What is the difference between
debugging and testing? You debug when you know or have identified problems in your code. Testing is the
art of systematically trying to break code, which you think is bug free. In this lecture, we will deal with
the detective work needed to break code and try and uncover inconsistencies and problems with your
working code.
<!--l. 23--><p class="noindent" >In the next lecture, we will discuss how to automate unit testing - an extremely important part of the
design and development process. In these notes, we discuss neat strategies <span 
class="cmbx-10">such as test as you</span>
<span 
class="cmbx-10">code</span>; for example, many bugs exist at what we call <span 
class="cmbx-10">boundaries</span>: e.g., a program that reads
data up to the end of an allocated buffer; a program expecting a stream of characters gets a
newline or EOF character as the first character it reads; a for loop not written as a <span 
class="cmbx-10">C idiom</span>
attempts to write one memory location beyond the end of an array (C can be dangerous, for
example, it has no subscript checking). If you think about common bugs that could creep
into code while writing code then that could save you significant time in the development
process.
<!--l. 27--><p class="noindent" >The material used in the lecture is strongly influenced by: <span 
class="cmbx-10">[KP, 1999] </span>The Practice of Programming
(Addison-Wesley Professional Computing Series) by Brian W. Kernighan, Rob Pike. The notes use a
number of programming examples from Chapter 6 on Testing. The text also reflects and cites material
from that chapter. This is an outstanding book and strongly recommended to advance your knowledge on
good programming practices. We use some coded examples from [KP, 1999] as cited in the
notes.
<!--l. 29--><p class="noindent" >Another short reference I like is <a 
href="http://www.ibm.com/developerworks/library/j-test.html" >Jeff Canna&#8217;s &#8220;Testing, Fun, Really&#8221;</a>. I would recommend that you read
Chapter 6 from [KP, 1999] and Jeff Canna article.
<!--l. 31--><p class="noindent" >BTW, you can skip these notes if you write bug free code ;-)
<h3 class="likesectionHead"><a 
 id="x1-4000"></a>Goals</h3>
<!--l. 35--><p class="noindent" >We plan to learn the following from today&#8217;s lecture:
                                                                                  
                                                                                  
     <ul class="itemize1">
     <li class="itemize">I write bug free code - testing is a waste of time?
     </li>
     <li class="itemize">TIP: Test as you write code
     </li>
     <li class="itemize">TIP: Use C idioms and be consistent when you write code
     </li>
     <li class="itemize">TIP: Test code at its boundaries
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only newline <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#8217;\n&#8217;</span></span></span> character
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only EOF character
     </li>
     <li class="itemize">TIP: Use asserts or in the case of TinySearch MY_ASSERT()
     </li>
     <li class="itemize">TIP: Test pre and post conditions
     </li>
     <li class="itemize">TIP: Test for the unexpected: aka defensive programming
     </li>
     <li class="itemize">TIP: Always check error returns from functions
     </li>
     <li class="itemize">TIP: Others useful things to do</li></ul>
<!--l. 51--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-5000"></a>I write bug free code - testing is a waste of time?</h3>
<!--l. 53--><p class="noindent" >Many people have the attitude that testing code is a waste of time and boring - why do it? When one
considers the software lifecycle discussed in class: procurement, requirements, design, coding, testing,
debugging, integration and bake off then I would say that testing and debugging take the largest chuck of
time. It is smart to develop tools and code to automate the testing of code. Why do this? Well the simple
answer is it saves time and pushes the sometimes tedious task of testing into tools and away from humans.
Imagine you design and develop a complex system and sell it to a customer who subsequently finds a
serious bug out in the wild; that is to say, when the product is deployed in a power station, across a
country such as an air traffic control system, in washing machines, or an app. The point is that you
fix the problem but how do you know you haven&#8217;t broken something else while fixing your
serious bug? You don&#8217;t know unless you have developed a set of tools to systematic retest
the code. If you have developed a set of integration tests, sub-system tests and unit tests
then you can quickly rerun them before you reship the new product with the bug fix. If all
                                                                                  
                                                                                  
the tests pass then you have some confidence that the change you made did not introduce
additional problems. Note, I use the phase &#8220;some confidence&#8221; because you are never 100%
sure.
<!--l. 55--><p class="noindent" >Let me restate the difference between debugging and testing again - with some philosophical comments. It
is good to have that clear in your mind:
<!--l. 57--><p class="noindent" ><span 
class="cmbx-10">Testing </span>is a determined, systematic attempt to break a program that you think is working. As discussed
above, putting smarts into the development of a set of tools and test harness can automate this process.
Story: this lecturer started his software career working for a company called Plessey Radar in
the UK. His first assignment was testing someone else code. Fortunately, this was very cool
because the code under test was the kernel of an Operating System. I did applied math at
university and knew nothing about software. It might have felt like grunt work to a newbie
on the job but I learnt how to design an operating system from the ground up. Later in my
career I worked for company that brought in a consultant to run integration tests again code -
my code. I was not happy dealing with testers until they found bugs in my code that was
already under beta release. After that I had time and respect for them. Today, I still think
producing smart testing tools to automate the testing of your code produces much more robust
code.
<!--l. 59--><p class="noindent" ><span 
class="cmbx-10">Debugging </span>is what you do when you know that the program is broken (e.g., segfault), fails (e.g.,
DDNODE is never linked into the hash table), underperforms (e.g., the memory leaks bring
the system to a slow but grinding halt) or acts inconsistently (e.g., never terminates when it
should). These are all bugs that testing can find. Better to find them and fix them. Sometimes
bugs cascade, i.e., one bug creates others and so on. These types of bugs are hard to fix. In
essence, the &#8220;bug chain&#8221; needs to be worked through to get to the real culprit at the start of
the chain. Many times it is not obvious what problems in a system are linked and therefore
requires some detective work: in the last lecture we <span 
class="cmbx-10">forced the bug out into the open</span>
before swatting that pesky bug - which, you recall, lurked at the boundary of the for loop
logic.
<!--l. 61--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-6000"></a>TIP: Test as you write code</h3>
<!--l. 63--><p class="noindent" >The earlier you find a problem with your code the better; it will save significant time and your company
money. You will also get respect from other programmers. Digging bugs out months after you have written
and forgotten the code is a serious challenge: test as you go. I know that for most labs you have sat a the
terminal and just hacked at the code to reveal and fix bugs - you sit there praying, hacking some
printfs and hit make and them run your code: you are doing this 100s of times. It is not a
smart to work like this and represents a dumb brute force method - you&#8217;ll get no respect in
industry for that. So be smart add a couple of new skills to your cs50 toolbox: &#8220;test as you go is
one&#8221;. Using C idioms is another great way to limit bugs; for example, if you do not blindly
hack code but enter code and sit back for a moment and read that while or for loop logic
through carefully then you have already tested your code on one level before you have hit
the gcc button. Doesn&#8217;t this make good sense? Yes, it does make good sense and having put
                                                                                  
                                                                                  
your code through inspection before you compile it is great, really great, and it comes for
free.
<!--l. 65--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-7000"></a>TIP: Use C idioms and be consistent when you write code</h3>
<!--l. 67--><p class="noindent" >You already know many C idioms even if we haven&#8217;t always labeled them that way. But there are many
ways to write a simple loop for example:
<div 
class="colorbox" id="colorbox1"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;first</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;&#x003C;=</span><span 
class="cmtt-10">&#x00A0;n-1)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;next</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;final</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;--i</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div></div>
<!--l. 97--><p class="noindent" >There are many ways to skin a cat - that is horrible saying, right and my cat Tiger would be alarmed. The
simple loop is developed in three different ways. But like the English language the C programming
language has idioms: where idiom means: <span 
class="cmbx-10">C idioms are conventional ways that experienced</span>
<span 
class="cmbx-10">programmers write common pieces of code. A central part of any language is developing</span>
<span 
class="cmbx-10">familiarity with its idioms </span>[KP, 1999].
<!--l. 102--><p class="noindent" >While all of the loops shown above would work they are not C idioms. The C idiom is:
<div 
class="colorbox" id="colorbox2"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Idiomatic</span><span 
class="cmtt-10">&#x00A0;form</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div>                 </div>
<!--l. 118--><p class="noindent" >Being consistent when programming C will help enormously. For example, if you are use to writing
idiomatic code then when you see a piece of code that is not idiomatic you should stop and take a close
look at that code: maybe a boundary problem is more likely? If code is written the same way each time
then when you see code that is not idiomatic it either suggests poor code or some genuine difference exists
that the idiom does not cover. Either way: take a second close look to convince yourself its one or the
other.
<!--l. 121--><p class="noindent" >Here are some more examples of C idioms that you should be familiar with:
<div 
class="colorbox" id="colorbox3"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Infinite</span><span 
class="cmtt-10">&#x00A0;loop</span><span 
class="cmtt-10">&#x00A0;idioms</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(;;)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;or</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(1)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;string</span><span 
class="cmtt-10">&#x00A0;copy</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;p</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(strlen(buf)+1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(p);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;strcpy(p,</span><span 
class="cmtt-10">&#x00A0;buf);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;reading</span><span 
class="cmtt-10">&#x00A0;in</span><span 
class="cmtt-10">&#x00A0;and</span><span 
class="cmtt-10">&#x00A0;writing</span><span 
class="cmtt-10">&#x00A0;out</span><span 
class="cmtt-10">&#x00A0;characters</span><span 
class="cmtt-10">&#x00A0;until</span><span 
class="cmtt-10">&#x00A0;EOF</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;((c</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;putchar(c);</span><br /><br /></div></div>
<!--l. 160--><p class="noindent" >Here are some TinySearch idioms that you should be using in your code. See solution for lab4 for many
examples.
<div 
class="colorbox" id="colorbox4"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK,</span><span 
class="cmtt-10">&#x00A0;BZERO</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;URLNODE*</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(URLNODE));</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(n);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;d;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;visited</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;BZERO(n-&#x003E;url,</span><span 
class="cmtt-10">&#x00A0;MAX_URL_LENGTH);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;LOG</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(page</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;LOG("CANNOT</span><span 
class="cmtt-10">&#x00A0;crawl</span><span 
class="cmtt-10">&#x00A0;seed</span><span 
class="cmtt-10">&#x00A0;page.</span><span 
class="cmtt-10">&#x00A0;Panic!");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;exit(-1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;ASSERT</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 191--><p class="noindent" >So write in idioms as much as possible; it limits bugs at boundaries.
<!--l. 193--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-8000"></a>TIP: Test code at its boundaries</h3>
<!--l. 195--><p class="noindent" >In what follows, we use a series of code snippets from [KP, 1999] to illustrate how to code to remove
boundary bugs. It is a simple yet elegant example of writing code to handle all the boundary conditions
that may present themselves.
                                                                                  
                                                                                  
<!--l. 197--><p class="noindent" >Boundary testing assumes you test a small snippet of code at a time - sort of micro testing of code
sequences or what should be idiomatic code. The example code does not use idioms and is poorly written
to cater for boundary bugs. It is set up to illustrate that. But we have all written poor code like this. The
take home from this section is how the code evolves once we think about where the boundary bugs
are. So, for example, as you write a loop of some sort check there and then that condition
branches the right way or that execution would go through the loop the correct number of
times.
<!--l. 199--><p class="noindent" >The technique is called <span 
class="cmbx-10">boundary condition testing </span>because you probe at the natural boundaries of the
program, its data and its data structures (if they exist). For example, for the code below we probe for the
following boundaries:
<!--l. 201--><p class="noindent" >1) empty input <br 
class="newline" />2) a single input character <br 
class="newline" />3) an exactly full array - but could be malloced buffer <br 
class="newline" />
<!--l. 205--><p class="noindent" >and so on. It could have been
<!--l. 207--><p class="noindent" >4) empty queue <br 
class="newline" />5) no collisions in a hash table <br 
class="newline" />6) collisions in a hash table <br 
class="newline" />7) add to the end of a cluster, etc.<br 
class="newline" />
<!--l. 212--><p class="noindent" >Consider the following code snippet from [KP, 1999]:
<!--l. 214--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-9000"></a>BOUNDARY TEST: Empty Input with only newline character</h3>
<div 
class="colorbox" id="colorbox5"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;(s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;&amp;&amp;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;++i)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;;</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;do</span><span 
class="cmtt-10">&#x00A0;nothing</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[--i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 234--><p class="noindent" >Looking at this code the first thing that should strike us is that it&#347; not a C idiom. That should make us
look very closely at the loop logic; particularly, the loops conditional logic. Maybe, after studying the code
thinking about characters being input we convince ourselves that the code is non idiomatic but works.
Now start to test boundaries. Consider 1) above where there is no input but a newline - the user simply
types carriage return for example. The resulting code would terminate immediately on the
first iteration with i set to zero. The last line that should replace a newline character with
a end of string character writes NULL to s[i-1], which is before the start of the array. Not
a good idea hey. Thinking about a boundary test gets the pesky bug out into the open to
swat.
<!--l. 236--><p class="noindent" >Here is the nasty edge case code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/edgecases.c" > edgecases.c&#x00A0;</a>
                                                                                  
                                                                                  
<!--l. 241--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-10000"></a>BOUNDARY TEST: Empty Input with only EOF character</h3>
<!--l. 243--><p class="noindent" >OK. The smart thing to do is rewrite this convoluted loop as an idiom and solve the problem; for
example:
<div 
class="colorbox" id="colorbox6"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;note</span><span 
class="cmtt-10">&#x00A0;we</span><span 
class="cmtt-10">&#x00A0;switch</span><span 
class="cmtt-10">&#x00A0;++i</span><span 
class="cmtt-10">&#x00A0;=&#x003E;</span><span 
class="cmtt-10">&#x00A0;i++,</span><span 
class="cmtt-10">&#x00A0;the</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 264--><p class="noindent" >Inspecting the code above we can easily see that the previous boundary problem is solved with the
new idiomatic code. It handles the case when the input is solely a newline beautifully. If we
mentally compute through reading 1, 2 or 3 characters we see it also works; for example a b c <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\n</span></span></span>
works.
<!--l. 266--><p class="noindent" ><span 
class="cmbx-10">s[0] is a </span><br 
class="newline" /><span 
class="cmbx-10">s[1] is b </span><br 
class="newline" /><span 
class="cmbx-10">s[2] is c </span><br 
class="newline" /><span 
class="cmbx-10">s[3] is 0 </span><br 
class="newline" />
<!--l. 271--><p class="noindent" >Looks good.
<!--l. 273--><p class="noindent" >Here is the better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/better.c" > better.c&#x00A0;</a>
<!--l. 277--><p class="noindent" >But what if we get an empty line and the first characters is an EOF? It breaks. Another pesky bug in our
code. More specifically, we do not cater for an unexpected action, well at least in terms of the person that
coded the loop. Someone hitting control D (EOF) would be a likely occurrences, well a probabilistic
occurrence.
<!--l. 279--><p class="noindent" >OK. Let&#347; fix this boundary bug.
<div 
class="colorbox" id="colorbox7"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 300--><p class="noindent" >That works! Nice piece of code now. Looks like we are done.
<!--l. 302--><p class="noindent" >Here is the even better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/evenbetter.c" > evenbetter.c&#x00A0;</a>
<!--l. 306--><p class="noindent" >We have removed and tested all the edge cases. The code handles all the edge cases nicely
now.
<!--l. 308--><p class="noindent" >// - where the first character is newline
<!--l. 310--><p class="noindent" >// - where the first character is EOF
<!--l. 312--><p class="noindent" >// - where there is one character
<!--l. 314--><p class="noindent" >// - where there are more characters input than the max size of the array
<!--l. 316--><p class="noindent" >// - where characters are entered terminated by a newline
<!--l. 318--><p class="noindent" >// - where there are characters entered terminated by a EOF (control D)
<!--l. 322--><p class="noindent" >Em...are we sure. There are other boundary problems that could lurk here. What happens if the array is
nearly full - does it work? What happens if the array is exactly full? Or over full - what happens if any of
these conditions occur followed by a newline. Are these boundary conditions catered for? We will leave you
to determine the answer to that question.
                                                                                  
                                                                                  
<!--l. 324--><p class="noindent" ><span 
class="cmbx-10">You get the idea. Bugs lurk at boundaries. Conversely, if code works at boundaries it is</span>
<span 
class="cmbx-10">likely to work elsewhere</span>
<!--l. 326--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-11000"></a>TIP: Test pre and post conditions</h3>
<!--l. 328--><p class="noindent" >It is always a good idea to test for pre and post conditions - that is before and after, respectively, some
program executes. For example, we have already used defensive program to check input values are with in
range - an example of pre-condition testing. Let&#347; look at another simple example out of [KP, 1999] that
computes the average of n elements in an array a[]. Closer inspection of the code reveals that there is a
problem is n is less than or equal to 0.
<div 
class="colorbox" id="colorbox8"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /></div></div>
<!--l. 355--><p class="noindent" >A natural question is what to do if someone calls avg() with n=0? An array of zero elements does not
make much sense but an average of 0 does. Should our code catch the division by zero? with an assert, or
abort, or complain or be silent? One reasonable approach is to just return 0 as the average if n is less than
or equal to zero. While the code is idiomatic in style we need to tweak it to test pre-condition, as shown
below - note: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n</span></span></span>
<div 
class="colorbox" id="colorbox9"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 384--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-12000"></a>TIP: Use asserts or in the case of TinySearch MY_ASSERT()</h3>
<!--l. 386--><p class="noindent" >We have used MY_ASSERT() macros in the development of TinySearch and in the unit testing code with
SHOULD_BE(); for example:
<div 
class="colorbox" id="colorbox10"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;dictionary_test.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DICTIONARY*</span><span 
class="cmtt-10">&#x00A0;dict</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;InitDictionary();</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d1;</span><span 
class="cmtt-10">&#x00A0;d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d2;</span><span 
class="cmtt-10">&#x00A0;d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;2;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d1,</span><span 
class="cmtt-10">&#x00A0;"1");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d2,</span><span 
class="cmtt-10">&#x00A0;"2");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;end</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]-&#x003E;next);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;start</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d2);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;next</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;crawler.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;current_depth,</span><span 
class="cmtt-10">&#x00A0;max_depth;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;URLToBeVisited;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char**</span><span 
class="cmtt-10">&#x00A0;URLsLists;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;page;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;current_depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 425--><p class="noindent" >C provides an assertion facility in assert.h useful for pre and post condition testing. Asserts are
usually used for unexpected failure where there is no clean way to recover the logic control. For
example our avg() function could include a different solution then n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;</span></span></span>= 0 using the assert
function:
<div 
class="colorbox" id="colorbox11"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sume</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;assert(n</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;0);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 456--><p class="noindent" >If the assertion is in fact violated it will cause an abort and standard message to be printed
out:
<!--l. 458--><p class="noindent" >Assertion failed: n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003E;</span></span></span> 0, file avgtest.c, line 7 <br 
class="newline" />Abort(crash)<br 
class="newline" />
                                                                                  
                                                                                  
<!--l. 461--><p class="noindent" >Assertions are very useful in validating the expected properties of an interface or range of input
arguments.
<!--l. 464--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-13000"></a>TIP: Test for the unexpected: aka defensive programming</h3>
<!--l. 466--><p class="noindent" >Your crawler and indexer uses defensive programming for checking that the input arguments are logically
correct: e.g., that a path actually existed. But a useful technique when coding is to &#8220;expect the
unexpected&#8221; or code for the unexpected. Adding checks for n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x00A0;&#x003C;</span></span></span> 0 in avg() is an example. Another is
below:
<div 
class="colorbox" id="colorbox12"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;100}</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*can&#8217;t</span><span 
class="cmtt-10">&#x00A0;happen,</span><span 
class="cmtt-10">&#x00A0;well</span><span 
class="cmtt-10">&#x00A0;possibly,</span><span 
class="cmtt-10">&#x00A0;at</span><span 
class="cmtt-10">&#x00A0;Dartmouth</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;?&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;90)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;A&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><br /></div></div>
<!--l. 488--><p class="noindent" >The CS50 automatic grading program - a snippet is shown above ;-) handles negative grades (I<img 
src="artoftesting0x.png" alt="v  "  class="acute" >e yet to
do that) and very large grades. If the unexpected happens the code returns a ? This is a good example of
defensive programming. In essence our programmer is coding against incorrect use or illegal data. Other
examples include:
<!--l. 493--><p class="noindent" >1) Out of range subscripts <br 
class="newline" />2) NULL pointers <br 
class="newline" />3) Divide by zero <br 
class="newline" />
<!--l. 498--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-14000"></a>TIP: Always check error returns from functions</h3>
<!--l. 500--><p class="noindent" >A really good programmer will always check the return status from functions, system calls, and libraries. If
you neglect to look at the return status then how do you know that the function really worked. If your
code assumes it did not fail but it did then the segfault or error will be hard to debug. Better to always
check the error status returned by functions.
<!--l. 506--><p class="noindent" >Another example from [KP, 1996].
<div 
class="colorbox" id="colorbox13"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fp</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;fopen(outfile,</span><span 
class="cmtt-10">&#x00A0;&#8216;&#8216;w&#8217;&#8217;);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(some</span><span 
class="cmtt-10">&#x00A0;expression)</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;write</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;file*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fprintf(fp,</span><span 
class="cmtt-10">&#x00A0;...);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(fclose(fp)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><span 
class="cmtt-10">&#x00A0;{</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;check</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;errors</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;some</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;error</span><span 
class="cmtt-10">&#x00A0;occurred</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 527--><p class="noindent" >Output errors can be serious problem and if the file being written above fails and the error status not
checked on fprintf then the file data can be lost. But the check above will save you from removing the old
file if the new one was not written probably.
                                                                                  
                                                                                  
<!--l. 531--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-15000"></a>TIP: Others useful things to do</h3>
<!--l. 533--><p class="noindent" >1) Test incrementally and build confidence in your code. <br 
class="newline" />2) Write unit tests that can be re-run once fixes or changes have been made. <br 
class="newline" />3) Write self-contained unit tests <br 
class="newline" />3.1) Test inputs and outputs.<br 
class="newline" />3.2) Test the dataflow through the program. <br 
class="newline" />3.3) Test all the execution paths through the program. <br 
class="newline" />3.4) Question: what environment do you need to set up to do 3.1-3.3<br 
class="newline" />4) Stress test the code; start simple and advance (test crawler at depth 1 .. 10 for example).<br 
class="newline" />5) Don&#8217;t implement new features if there are known bugs in the system.<br 
class="newline" />6) Test for portability: run code and tests on multiple machines/OSs.<br 
class="newline" />7) Before shipping code make sure that the test code ifdefs are off.<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="cmbx-10">If you follow at least 50% of the tips in these notes you will write better code and it will</span>
<span 
class="cmbx-10">have considerably less bugs than if you did not apply these simple tips and strategy. Or your</span>
<span 
class="cmbx-10">money back.</span>
 
</body></html> 

                                                                                  


http://www.cs.dartmouth.edu/~campbell/cs50/artoftesting.html
Depth: 2
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="artoftesting.tex"> 
<meta name="date" content="2014-02-11 22:45:00"> 
<link rel="stylesheet" type="text/css" href="artoftesting.css"> 
</head><body 
>
<h1 class="likepartHead"><a 
 id="x1-1000"></a>CS 50 Software Design and Implementation</h1>
<h1 class="likepartHead"><a 
 id="x1-2000"></a>Lecture 17</h1>
<h1 class="likepartHead"><a 
 id="x1-3000"></a>The Art of Testing (and Writing Good Code)</h1>
<!--l. 21--><p class="noindent" >Edsger Dijkstra once said that testing can demonstrate the presence of bugs but not their absence. That is
good to keep in mind when you are developing code - good code. What is the difference between
debugging and testing? You debug when you know or have identified problems in your code. Testing is the
art of systematically trying to break code, which you think is bug free. In this lecture, we will deal with
the detective work needed to break code and try and uncover inconsistencies and problems with your
working code.
<!--l. 23--><p class="noindent" >In the next lecture, we will discuss how to automate unit testing - an extremely important part of the
design and development process. In these notes, we discuss neat strategies <span 
class="cmbx-10">such as test as you</span>
<span 
class="cmbx-10">code</span>; for example, many bugs exist at what we call <span 
class="cmbx-10">boundaries</span>: e.g., a program that reads
data up to the end of an allocated buffer; a program expecting a stream of characters gets a
newline or EOF character as the first character it reads; a for loop not written as a <span 
class="cmbx-10">C idiom</span>
attempts to write one memory location beyond the end of an array (C can be dangerous, for
example, it has no subscript checking). If you think about common bugs that could creep
into code while writing code then that could save you significant time in the development
process.
<!--l. 27--><p class="noindent" >The material used in the lecture is strongly influenced by: <span 
class="cmbx-10">[KP, 1999] </span>The Practice of Programming
(Addison-Wesley Professional Computing Series) by Brian W. Kernighan, Rob Pike. The notes use a
number of programming examples from Chapter 6 on Testing. The text also reflects and cites material
from that chapter. This is an outstanding book and strongly recommended to advance your knowledge on
good programming practices. We use some coded examples from [KP, 1999] as cited in the
notes.
<!--l. 29--><p class="noindent" >Another short reference I like is <a 
href="http://www.ibm.com/developerworks/library/j-test.html" >Jeff Canna&#8217;s &#8220;Testing, Fun, Really&#8221;</a>. I would recommend that you read
Chapter 6 from [KP, 1999] and Jeff Canna article.
<!--l. 31--><p class="noindent" >BTW, you can skip these notes if you write bug free code ;-)
<h3 class="likesectionHead"><a 
 id="x1-4000"></a>Goals</h3>
<!--l. 35--><p class="noindent" >We plan to learn the following from today&#8217;s lecture:
                                                                                  
                                                                                  
     <ul class="itemize1">
     <li class="itemize">I write bug free code - testing is a waste of time?
     </li>
     <li class="itemize">TIP: Test as you write code
     </li>
     <li class="itemize">TIP: Use C idioms and be consistent when you write code
     </li>
     <li class="itemize">TIP: Test code at its boundaries
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only newline <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#8217;\n&#8217;</span></span></span> character
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only EOF character
     </li>
     <li class="itemize">TIP: Use asserts or in the case of TinySearch MY_ASSERT()
     </li>
     <li class="itemize">TIP: Test pre and post conditions
     </li>
     <li class="itemize">TIP: Test for the unexpected: aka defensive programming
     </li>
     <li class="itemize">TIP: Always check error returns from functions
     </li>
     <li class="itemize">TIP: Others useful things to do</li></ul>
<!--l. 51--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-5000"></a>I write bug free code - testing is a waste of time?</h3>
<!--l. 53--><p class="noindent" >Many people have the attitude that testing code is a waste of time and boring - why do it? When one
considers the software lifecycle discussed in class: procurement, requirements, design, coding, testing,
debugging, integration and bake off then I would say that testing and debugging take the largest chuck of
time. It is smart to develop tools and code to automate the testing of code. Why do this? Well the simple
answer is it saves time and pushes the sometimes tedious task of testing into tools and away from humans.
Imagine you design and develop a complex system and sell it to a customer who subsequently finds a
serious bug out in the wild; that is to say, when the product is deployed in a power station, across a
country such as an air traffic control system, in washing machines, or an app. The point is that you
fix the problem but how do you know you haven&#8217;t broken something else while fixing your
serious bug? You don&#8217;t know unless you have developed a set of tools to systematic retest
the code. If you have developed a set of integration tests, sub-system tests and unit tests
then you can quickly rerun them before you reship the new product with the bug fix. If all
                                                                                  
                                                                                  
the tests pass then you have some confidence that the change you made did not introduce
additional problems. Note, I use the phase &#8220;some confidence&#8221; because you are never 100%
sure.
<!--l. 55--><p class="noindent" >Let me restate the difference between debugging and testing again - with some philosophical comments. It
is good to have that clear in your mind:
<!--l. 57--><p class="noindent" ><span 
class="cmbx-10">Testing </span>is a determined, systematic attempt to break a program that you think is working. As discussed
above, putting smarts into the development of a set of tools and test harness can automate this process.
Story: this lecturer started his software career working for a company called Plessey Radar in
the UK. His first assignment was testing someone else code. Fortunately, this was very cool
because the code under test was the kernel of an Operating System. I did applied math at
university and knew nothing about software. It might have felt like grunt work to a newbie
on the job but I learnt how to design an operating system from the ground up. Later in my
career I worked for company that brought in a consultant to run integration tests again code -
my code. I was not happy dealing with testers until they found bugs in my code that was
already under beta release. After that I had time and respect for them. Today, I still think
producing smart testing tools to automate the testing of your code produces much more robust
code.
<!--l. 59--><p class="noindent" ><span 
class="cmbx-10">Debugging </span>is what you do when you know that the program is broken (e.g., segfault), fails (e.g.,
DDNODE is never linked into the hash table), underperforms (e.g., the memory leaks bring
the system to a slow but grinding halt) or acts inconsistently (e.g., never terminates when it
should). These are all bugs that testing can find. Better to find them and fix them. Sometimes
bugs cascade, i.e., one bug creates others and so on. These types of bugs are hard to fix. In
essence, the &#8220;bug chain&#8221; needs to be worked through to get to the real culprit at the start of
the chain. Many times it is not obvious what problems in a system are linked and therefore
requires some detective work: in the last lecture we <span 
class="cmbx-10">forced the bug out into the open</span>
before swatting that pesky bug - which, you recall, lurked at the boundary of the for loop
logic.
<!--l. 61--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-6000"></a>TIP: Test as you write code</h3>
<!--l. 63--><p class="noindent" >The earlier you find a problem with your code the better; it will save significant time and your company
money. You will also get respect from other programmers. Digging bugs out months after you have written
and forgotten the code is a serious challenge: test as you go. I know that for most labs you have sat a the
terminal and just hacked at the code to reveal and fix bugs - you sit there praying, hacking some
printfs and hit make and them run your code: you are doing this 100s of times. It is not a
smart to work like this and represents a dumb brute force method - you&#8217;ll get no respect in
industry for that. So be smart add a couple of new skills to your cs50 toolbox: &#8220;test as you go is
one&#8221;. Using C idioms is another great way to limit bugs; for example, if you do not blindly
hack code but enter code and sit back for a moment and read that while or for loop logic
through carefully then you have already tested your code on one level before you have hit
the gcc button. Doesn&#8217;t this make good sense? Yes, it does make good sense and having put
                                                                                  
                                                                                  
your code through inspection before you compile it is great, really great, and it comes for
free.
<!--l. 65--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-7000"></a>TIP: Use C idioms and be consistent when you write code</h3>
<!--l. 67--><p class="noindent" >You already know many C idioms even if we haven&#8217;t always labeled them that way. But there are many
ways to write a simple loop for example:
<div 
class="colorbox" id="colorbox1"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;first</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;&#x003C;=</span><span 
class="cmtt-10">&#x00A0;n-1)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;next</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;final</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;--i</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div></div>
<!--l. 97--><p class="noindent" >There are many ways to skin a cat - that is horrible saying, right and my cat Tiger would be alarmed. The
simple loop is developed in three different ways. But like the English language the C programming
language has idioms: where idiom means: <span 
class="cmbx-10">C idioms are conventional ways that experienced</span>
<span 
class="cmbx-10">programmers write common pieces of code. A central part of any language is developing</span>
<span 
class="cmbx-10">familiarity with its idioms </span>[KP, 1999].
<!--l. 102--><p class="noindent" >While all of the loops shown above would work they are not C idioms. The C idiom is:
<div 
class="colorbox" id="colorbox2"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Idiomatic</span><span 
class="cmtt-10">&#x00A0;form</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div>                 </div>
<!--l. 118--><p class="noindent" >Being consistent when programming C will help enormously. For example, if you are use to writing
idiomatic code then when you see a piece of code that is not idiomatic you should stop and take a close
look at that code: maybe a boundary problem is more likely? If code is written the same way each time
then when you see code that is not idiomatic it either suggests poor code or some genuine difference exists
that the idiom does not cover. Either way: take a second close look to convince yourself its one or the
other.
<!--l. 121--><p class="noindent" >Here are some more examples of C idioms that you should be familiar with:
<div 
class="colorbox" id="colorbox3"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Infinite</span><span 
class="cmtt-10">&#x00A0;loop</span><span 
class="cmtt-10">&#x00A0;idioms</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(;;)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;or</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(1)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;string</span><span 
class="cmtt-10">&#x00A0;copy</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;p</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(strlen(buf)+1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(p);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;strcpy(p,</span><span 
class="cmtt-10">&#x00A0;buf);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;reading</span><span 
class="cmtt-10">&#x00A0;in</span><span 
class="cmtt-10">&#x00A0;and</span><span 
class="cmtt-10">&#x00A0;writing</span><span 
class="cmtt-10">&#x00A0;out</span><span 
class="cmtt-10">&#x00A0;characters</span><span 
class="cmtt-10">&#x00A0;until</span><span 
class="cmtt-10">&#x00A0;EOF</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;((c</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;putchar(c);</span><br /><br /></div></div>
<!--l. 160--><p class="noindent" >Here are some TinySearch idioms that you should be using in your code. See solution for lab4 for many
examples.
<div 
class="colorbox" id="colorbox4"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK,</span><span 
class="cmtt-10">&#x00A0;BZERO</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;URLNODE*</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(URLNODE));</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(n);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;d;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;visited</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;BZERO(n-&#x003E;url,</span><span 
class="cmtt-10">&#x00A0;MAX_URL_LENGTH);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;LOG</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(page</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;LOG("CANNOT</span><span 
class="cmtt-10">&#x00A0;crawl</span><span 
class="cmtt-10">&#x00A0;seed</span><span 
class="cmtt-10">&#x00A0;page.</span><span 
class="cmtt-10">&#x00A0;Panic!");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;exit(-1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;ASSERT</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 191--><p class="noindent" >So write in idioms as much as possible; it limits bugs at boundaries.
<!--l. 193--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-8000"></a>TIP: Test code at its boundaries</h3>
<!--l. 195--><p class="noindent" >In what follows, we use a series of code snippets from [KP, 1999] to illustrate how to code to remove
boundary bugs. It is a simple yet elegant example of writing code to handle all the boundary conditions
that may present themselves.
                                                                                  
                                                                                  
<!--l. 197--><p class="noindent" >Boundary testing assumes you test a small snippet of code at a time - sort of micro testing of code
sequences or what should be idiomatic code. The example code does not use idioms and is poorly written
to cater for boundary bugs. It is set up to illustrate that. But we have all written poor code like this. The
take home from this section is how the code evolves once we think about where the boundary bugs
are. So, for example, as you write a loop of some sort check there and then that condition
branches the right way or that execution would go through the loop the correct number of
times.
<!--l. 199--><p class="noindent" >The technique is called <span 
class="cmbx-10">boundary condition testing </span>because you probe at the natural boundaries of the
program, its data and its data structures (if they exist). For example, for the code below we probe for the
following boundaries:
<!--l. 201--><p class="noindent" >1) empty input <br 
class="newline" />2) a single input character <br 
class="newline" />3) an exactly full array - but could be malloced buffer <br 
class="newline" />
<!--l. 205--><p class="noindent" >and so on. It could have been
<!--l. 207--><p class="noindent" >4) empty queue <br 
class="newline" />5) no collisions in a hash table <br 
class="newline" />6) collisions in a hash table <br 
class="newline" />7) add to the end of a cluster, etc.<br 
class="newline" />
<!--l. 212--><p class="noindent" >Consider the following code snippet from [KP, 1999]:
<!--l. 214--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-9000"></a>BOUNDARY TEST: Empty Input with only newline character</h3>
<div 
class="colorbox" id="colorbox5"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;(s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;&amp;&amp;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;++i)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;;</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;do</span><span 
class="cmtt-10">&#x00A0;nothing</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[--i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 234--><p class="noindent" >Looking at this code the first thing that should strike us is that it&#347; not a C idiom. That should make us
look very closely at the loop logic; particularly, the loops conditional logic. Maybe, after studying the code
thinking about characters being input we convince ourselves that the code is non idiomatic but works.
Now start to test boundaries. Consider 1) above where there is no input but a newline - the user simply
types carriage return for example. The resulting code would terminate immediately on the
first iteration with i set to zero. The last line that should replace a newline character with
a end of string character writes NULL to s[i-1], which is before the start of the array. Not
a good idea hey. Thinking about a boundary test gets the pesky bug out into the open to
swat.
<!--l. 236--><p class="noindent" >Here is the nasty edge case code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/edgecases.c" > edgecases.c&#x00A0;</a>
                                                                                  
                                                                                  
<!--l. 241--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-10000"></a>BOUNDARY TEST: Empty Input with only EOF character</h3>
<!--l. 243--><p class="noindent" >OK. The smart thing to do is rewrite this convoluted loop as an idiom and solve the problem; for
example:
<div 
class="colorbox" id="colorbox6"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;note</span><span 
class="cmtt-10">&#x00A0;we</span><span 
class="cmtt-10">&#x00A0;switch</span><span 
class="cmtt-10">&#x00A0;++i</span><span 
class="cmtt-10">&#x00A0;=&#x003E;</span><span 
class="cmtt-10">&#x00A0;i++,</span><span 
class="cmtt-10">&#x00A0;the</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 264--><p class="noindent" >Inspecting the code above we can easily see that the previous boundary problem is solved with the
new idiomatic code. It handles the case when the input is solely a newline beautifully. If we
mentally compute through reading 1, 2 or 3 characters we see it also works; for example a b c <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\n</span></span></span>
works.
<!--l. 266--><p class="noindent" ><span 
class="cmbx-10">s[0] is a </span><br 
class="newline" /><span 
class="cmbx-10">s[1] is b </span><br 
class="newline" /><span 
class="cmbx-10">s[2] is c </span><br 
class="newline" /><span 
class="cmbx-10">s[3] is 0 </span><br 
class="newline" />
<!--l. 271--><p class="noindent" >Looks good.
<!--l. 273--><p class="noindent" >Here is the better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/better.c" > better.c&#x00A0;</a>
<!--l. 277--><p class="noindent" >But what if we get an empty line and the first characters is an EOF? It breaks. Another pesky bug in our
code. More specifically, we do not cater for an unexpected action, well at least in terms of the person that
coded the loop. Someone hitting control D (EOF) would be a likely occurrences, well a probabilistic
occurrence.
<!--l. 279--><p class="noindent" >OK. Let&#347; fix this boundary bug.
<div 
class="colorbox" id="colorbox7"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 300--><p class="noindent" >That works! Nice piece of code now. Looks like we are done.
<!--l. 302--><p class="noindent" >Here is the even better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/evenbetter.c" > evenbetter.c&#x00A0;</a>
<!--l. 306--><p class="noindent" >We have removed and tested all the edge cases. The code handles all the edge cases nicely
now.
<!--l. 308--><p class="noindent" >// - where the first character is newline
<!--l. 310--><p class="noindent" >// - where the first character is EOF
<!--l. 312--><p class="noindent" >// - where there is one character
<!--l. 314--><p class="noindent" >// - where there are more characters input than the max size of the array
<!--l. 316--><p class="noindent" >// - where characters are entered terminated by a newline
<!--l. 318--><p class="noindent" >// - where there are characters entered terminated by a EOF (control D)
<!--l. 322--><p class="noindent" >Em...are we sure. There are other boundary problems that could lurk here. What happens if the array is
nearly full - does it work? What happens if the array is exactly full? Or over full - what happens if any of
these conditions occur followed by a newline. Are these boundary conditions catered for? We will leave you
to determine the answer to that question.
                                                                                  
                                                                                  
<!--l. 324--><p class="noindent" ><span 
class="cmbx-10">You get the idea. Bugs lurk at boundaries. Conversely, if code works at boundaries it is</span>
<span 
class="cmbx-10">likely to work elsewhere</span>
<!--l. 326--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-11000"></a>TIP: Test pre and post conditions</h3>
<!--l. 328--><p class="noindent" >It is always a good idea to test for pre and post conditions - that is before and after, respectively, some
program executes. For example, we have already used defensive program to check input values are with in
range - an example of pre-condition testing. Let&#347; look at another simple example out of [KP, 1999] that
computes the average of n elements in an array a[]. Closer inspection of the code reveals that there is a
problem is n is less than or equal to 0.
<div 
class="colorbox" id="colorbox8"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /></div></div>
<!--l. 355--><p class="noindent" >A natural question is what to do if someone calls avg() with n=0? An array of zero elements does not
make much sense but an average of 0 does. Should our code catch the division by zero? with an assert, or
abort, or complain or be silent? One reasonable approach is to just return 0 as the average if n is less than
or equal to zero. While the code is idiomatic in style we need to tweak it to test pre-condition, as shown
below - note: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n</span></span></span>
<div 
class="colorbox" id="colorbox9"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 384--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-12000"></a>TIP: Use asserts or in the case of TinySearch MY_ASSERT()</h3>
<!--l. 386--><p class="noindent" >We have used MY_ASSERT() macros in the development of TinySearch and in the unit testing code with
SHOULD_BE(); for example:
<div 
class="colorbox" id="colorbox10"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;dictionary_test.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DICTIONARY*</span><span 
class="cmtt-10">&#x00A0;dict</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;InitDictionary();</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d1;</span><span 
class="cmtt-10">&#x00A0;d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d2;</span><span 
class="cmtt-10">&#x00A0;d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;2;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d1,</span><span 
class="cmtt-10">&#x00A0;"1");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d2,</span><span 
class="cmtt-10">&#x00A0;"2");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;end</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]-&#x003E;next);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;start</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d2);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;next</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;crawler.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;current_depth,</span><span 
class="cmtt-10">&#x00A0;max_depth;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;URLToBeVisited;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char**</span><span 
class="cmtt-10">&#x00A0;URLsLists;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;page;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;current_depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 425--><p class="noindent" >C provides an assertion facility in assert.h useful for pre and post condition testing. Asserts are
usually used for unexpected failure where there is no clean way to recover the logic control. For
example our avg() function could include a different solution then n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;</span></span></span>= 0 using the assert
function:
<div 
class="colorbox" id="colorbox11"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sume</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;assert(n</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;0);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 456--><p class="noindent" >If the assertion is in fact violated it will cause an abort and standard message to be printed
out:
<!--l. 458--><p class="noindent" >Assertion failed: n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003E;</span></span></span> 0, file avgtest.c, line 7 <br 
class="newline" />Abort(crash)<br 
class="newline" />
                                                                                  
                                                                                  
<!--l. 461--><p class="noindent" >Assertions are very useful in validating the expected properties of an interface or range of input
arguments.
<!--l. 464--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-13000"></a>TIP: Test for the unexpected: aka defensive programming</h3>
<!--l. 466--><p class="noindent" >Your crawler and indexer uses defensive programming for checking that the input arguments are logically
correct: e.g., that a path actually existed. But a useful technique when coding is to &#8220;expect the
unexpected&#8221; or code for the unexpected. Adding checks for n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x00A0;&#x003C;</span></span></span> 0 in avg() is an example. Another is
below:
<div 
class="colorbox" id="colorbox12"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;100}</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*can&#8217;t</span><span 
class="cmtt-10">&#x00A0;happen,</span><span 
class="cmtt-10">&#x00A0;well</span><span 
class="cmtt-10">&#x00A0;possibly,</span><span 
class="cmtt-10">&#x00A0;at</span><span 
class="cmtt-10">&#x00A0;Dartmouth</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;?&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;90)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;A&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><br /></div></div>
<!--l. 488--><p class="noindent" >The CS50 automatic grading program - a snippet is shown above ;-) handles negative grades (I<img 
src="artoftesting0x.png" alt="v  "  class="acute" >e yet to
do that) and very large grades. If the unexpected happens the code returns a ? This is a good example of
defensive programming. In essence our programmer is coding against incorrect use or illegal data. Other
examples include:
<!--l. 493--><p class="noindent" >1) Out of range subscripts <br 
class="newline" />2) NULL pointers <br 
class="newline" />3) Divide by zero <br 
class="newline" />
<!--l. 498--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-14000"></a>TIP: Always check error returns from functions</h3>
<!--l. 500--><p class="noindent" >A really good programmer will always check the return status from functions, system calls, and libraries. If
you neglect to look at the return status then how do you know that the function really worked. If your
code assumes it did not fail but it did then the segfault or error will be hard to debug. Better to always
check the error status returned by functions.
<!--l. 506--><p class="noindent" >Another example from [KP, 1996].
<div 
class="colorbox" id="colorbox13"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fp</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;fopen(outfile,</span><span 
class="cmtt-10">&#x00A0;&#8216;&#8216;w&#8217;&#8217;);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(some</span><span 
class="cmtt-10">&#x00A0;expression)</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;write</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;file*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fprintf(fp,</span><span 
class="cmtt-10">&#x00A0;...);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(fclose(fp)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><span 
class="cmtt-10">&#x00A0;{</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;check</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;errors</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;some</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;error</span><span 
class="cmtt-10">&#x00A0;occurred</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 527--><p class="noindent" >Output errors can be serious problem and if the file being written above fails and the error status not
checked on fprintf then the file data can be lost. But the check above will save you from removing the old
file if the new one was not written probably.
                                                                                  
                                                                                  
<!--l. 531--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-15000"></a>TIP: Others useful things to do</h3>
<!--l. 533--><p class="noindent" >1) Test incrementally and build confidence in your code. <br 
class="newline" />2) Write unit tests that can be re-run once fixes or changes have been made. <br 
class="newline" />3) Write self-contained unit tests <br 
class="newline" />3.1) Test inputs and outputs.<br 
class="newline" />3.2) Test the dataflow through the program. <br 
class="newline" />3.3) Test all the execution paths through the program. <br 
class="newline" />3.4) Question: what environment do you need to set up to do 3.1-3.3<br 
class="newline" />4) Stress test the code; start simple and advance (test crawler at depth 1 .. 10 for example).<br 
class="newline" />5) Don&#8217;t implement new features if there are known bugs in the system.<br 
class="newline" />6) Test for portability: run code and tests on multiple machines/OSs.<br 
class="newline" />7) Before shipping code make sure that the test code ifdefs are off.<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="cmbx-10">If you follow at least 50% of the tips in these notes you will write better code and it will</span>
<span 
class="cmbx-10">have considerably less bugs than if you did not apply these simple tips and strategy. Or your</span>
<span 
class="cmbx-10">money back.</span>
 
</body></html> 

                                                                                  


http://www.cs.dartmouth.edu/~campbell/cs50/artoftesting.html
Depth: 2
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="artoftesting.tex"> 
<meta name="date" content="2014-02-11 22:45:00"> 
<link rel="stylesheet" type="text/css" href="artoftesting.css"> 
</head><body 
>
<h1 class="likepartHead"><a 
 id="x1-1000"></a>CS 50 Software Design and Implementation</h1>
<h1 class="likepartHead"><a 
 id="x1-2000"></a>Lecture 17</h1>
<h1 class="likepartHead"><a 
 id="x1-3000"></a>The Art of Testing (and Writing Good Code)</h1>
<!--l. 21--><p class="noindent" >Edsger Dijkstra once said that testing can demonstrate the presence of bugs but not their absence. That is
good to keep in mind when you are developing code - good code. What is the difference between
debugging and testing? You debug when you know or have identified problems in your code. Testing is the
art of systematically trying to break code, which you think is bug free. In this lecture, we will deal with
the detective work needed to break code and try and uncover inconsistencies and problems with your
working code.
<!--l. 23--><p class="noindent" >In the next lecture, we will discuss how to automate unit testing - an extremely important part of the
design and development process. In these notes, we discuss neat strategies <span 
class="cmbx-10">such as test as you</span>
<span 
class="cmbx-10">code</span>; for example, many bugs exist at what we call <span 
class="cmbx-10">boundaries</span>: e.g., a program that reads
data up to the end of an allocated buffer; a program expecting a stream of characters gets a
newline or EOF character as the first character it reads; a for loop not written as a <span 
class="cmbx-10">C idiom</span>
attempts to write one memory location beyond the end of an array (C can be dangerous, for
example, it has no subscript checking). If you think about common bugs that could creep
into code while writing code then that could save you significant time in the development
process.
<!--l. 27--><p class="noindent" >The material used in the lecture is strongly influenced by: <span 
class="cmbx-10">[KP, 1999] </span>The Practice of Programming
(Addison-Wesley Professional Computing Series) by Brian W. Kernighan, Rob Pike. The notes use a
number of programming examples from Chapter 6 on Testing. The text also reflects and cites material
from that chapter. This is an outstanding book and strongly recommended to advance your knowledge on
good programming practices. We use some coded examples from [KP, 1999] as cited in the
notes.
<!--l. 29--><p class="noindent" >Another short reference I like is <a 
href="http://www.ibm.com/developerworks/library/j-test.html" >Jeff Canna&#8217;s &#8220;Testing, Fun, Really&#8221;</a>. I would recommend that you read
Chapter 6 from [KP, 1999] and Jeff Canna article.
<!--l. 31--><p class="noindent" >BTW, you can skip these notes if you write bug free code ;-)
<h3 class="likesectionHead"><a 
 id="x1-4000"></a>Goals</h3>
<!--l. 35--><p class="noindent" >We plan to learn the following from today&#8217;s lecture:
                                                                                  
                                                                                  
     <ul class="itemize1">
     <li class="itemize">I write bug free code - testing is a waste of time?
     </li>
     <li class="itemize">TIP: Test as you write code
     </li>
     <li class="itemize">TIP: Use C idioms and be consistent when you write code
     </li>
     <li class="itemize">TIP: Test code at its boundaries
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only newline <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#8217;\n&#8217;</span></span></span> character
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only EOF character
     </li>
     <li class="itemize">TIP: Use asserts or in the case of TinySearch MY_ASSERT()
     </li>
     <li class="itemize">TIP: Test pre and post conditions
     </li>
     <li class="itemize">TIP: Test for the unexpected: aka defensive programming
     </li>
     <li class="itemize">TIP: Always check error returns from functions
     </li>
     <li class="itemize">TIP: Others useful things to do</li></ul>
<!--l. 51--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-5000"></a>I write bug free code - testing is a waste of time?</h3>
<!--l. 53--><p class="noindent" >Many people have the attitude that testing code is a waste of time and boring - why do it? When one
considers the software lifecycle discussed in class: procurement, requirements, design, coding, testing,
debugging, integration and bake off then I would say that testing and debugging take the largest chuck of
time. It is smart to develop tools and code to automate the testing of code. Why do this? Well the simple
answer is it saves time and pushes the sometimes tedious task of testing into tools and away from humans.
Imagine you design and develop a complex system and sell it to a customer who subsequently finds a
serious bug out in the wild; that is to say, when the product is deployed in a power station, across a
country such as an air traffic control system, in washing machines, or an app. The point is that you
fix the problem but how do you know you haven&#8217;t broken something else while fixing your
serious bug? You don&#8217;t know unless you have developed a set of tools to systematic retest
the code. If you have developed a set of integration tests, sub-system tests and unit tests
then you can quickly rerun them before you reship the new product with the bug fix. If all
                                                                                  
                                                                                  
the tests pass then you have some confidence that the change you made did not introduce
additional problems. Note, I use the phase &#8220;some confidence&#8221; because you are never 100%
sure.
<!--l. 55--><p class="noindent" >Let me restate the difference between debugging and testing again - with some philosophical comments. It
is good to have that clear in your mind:
<!--l. 57--><p class="noindent" ><span 
class="cmbx-10">Testing </span>is a determined, systematic attempt to break a program that you think is working. As discussed
above, putting smarts into the development of a set of tools and test harness can automate this process.
Story: this lecturer started his software career working for a company called Plessey Radar in
the UK. His first assignment was testing someone else code. Fortunately, this was very cool
because the code under test was the kernel of an Operating System. I did applied math at
university and knew nothing about software. It might have felt like grunt work to a newbie
on the job but I learnt how to design an operating system from the ground up. Later in my
career I worked for company that brought in a consultant to run integration tests again code -
my code. I was not happy dealing with testers until they found bugs in my code that was
already under beta release. After that I had time and respect for them. Today, I still think
producing smart testing tools to automate the testing of your code produces much more robust
code.
<!--l. 59--><p class="noindent" ><span 
class="cmbx-10">Debugging </span>is what you do when you know that the program is broken (e.g., segfault), fails (e.g.,
DDNODE is never linked into the hash table), underperforms (e.g., the memory leaks bring
the system to a slow but grinding halt) or acts inconsistently (e.g., never terminates when it
should). These are all bugs that testing can find. Better to find them and fix them. Sometimes
bugs cascade, i.e., one bug creates others and so on. These types of bugs are hard to fix. In
essence, the &#8220;bug chain&#8221; needs to be worked through to get to the real culprit at the start of
the chain. Many times it is not obvious what problems in a system are linked and therefore
requires some detective work: in the last lecture we <span 
class="cmbx-10">forced the bug out into the open</span>
before swatting that pesky bug - which, you recall, lurked at the boundary of the for loop
logic.
<!--l. 61--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-6000"></a>TIP: Test as you write code</h3>
<!--l. 63--><p class="noindent" >The earlier you find a problem with your code the better; it will save significant time and your company
money. You will also get respect from other programmers. Digging bugs out months after you have written
and forgotten the code is a serious challenge: test as you go. I know that for most labs you have sat a the
terminal and just hacked at the code to reveal and fix bugs - you sit there praying, hacking some
printfs and hit make and them run your code: you are doing this 100s of times. It is not a
smart to work like this and represents a dumb brute force method - you&#8217;ll get no respect in
industry for that. So be smart add a couple of new skills to your cs50 toolbox: &#8220;test as you go is
one&#8221;. Using C idioms is another great way to limit bugs; for example, if you do not blindly
hack code but enter code and sit back for a moment and read that while or for loop logic
through carefully then you have already tested your code on one level before you have hit
the gcc button. Doesn&#8217;t this make good sense? Yes, it does make good sense and having put
                                                                                  
                                                                                  
your code through inspection before you compile it is great, really great, and it comes for
free.
<!--l. 65--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-7000"></a>TIP: Use C idioms and be consistent when you write code</h3>
<!--l. 67--><p class="noindent" >You already know many C idioms even if we haven&#8217;t always labeled them that way. But there are many
ways to write a simple loop for example:
<div 
class="colorbox" id="colorbox1"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;first</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;&#x003C;=</span><span 
class="cmtt-10">&#x00A0;n-1)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;next</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;final</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;--i</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div></div>
<!--l. 97--><p class="noindent" >There are many ways to skin a cat - that is horrible saying, right and my cat Tiger would be alarmed. The
simple loop is developed in three different ways. But like the English language the C programming
language has idioms: where idiom means: <span 
class="cmbx-10">C idioms are conventional ways that experienced</span>
<span 
class="cmbx-10">programmers write common pieces of code. A central part of any language is developing</span>
<span 
class="cmbx-10">familiarity with its idioms </span>[KP, 1999].
<!--l. 102--><p class="noindent" >While all of the loops shown above would work they are not C idioms. The C idiom is:
<div 
class="colorbox" id="colorbox2"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Idiomatic</span><span 
class="cmtt-10">&#x00A0;form</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div>                 </div>
<!--l. 118--><p class="noindent" >Being consistent when programming C will help enormously. For example, if you are use to writing
idiomatic code then when you see a piece of code that is not idiomatic you should stop and take a close
look at that code: maybe a boundary problem is more likely? If code is written the same way each time
then when you see code that is not idiomatic it either suggests poor code or some genuine difference exists
that the idiom does not cover. Either way: take a second close look to convince yourself its one or the
other.
<!--l. 121--><p class="noindent" >Here are some more examples of C idioms that you should be familiar with:
<div 
class="colorbox" id="colorbox3"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Infinite</span><span 
class="cmtt-10">&#x00A0;loop</span><span 
class="cmtt-10">&#x00A0;idioms</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(;;)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;or</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(1)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;string</span><span 
class="cmtt-10">&#x00A0;copy</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;p</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(strlen(buf)+1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(p);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;strcpy(p,</span><span 
class="cmtt-10">&#x00A0;buf);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;reading</span><span 
class="cmtt-10">&#x00A0;in</span><span 
class="cmtt-10">&#x00A0;and</span><span 
class="cmtt-10">&#x00A0;writing</span><span 
class="cmtt-10">&#x00A0;out</span><span 
class="cmtt-10">&#x00A0;characters</span><span 
class="cmtt-10">&#x00A0;until</span><span 
class="cmtt-10">&#x00A0;EOF</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;((c</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;putchar(c);</span><br /><br /></div></div>
<!--l. 160--><p class="noindent" >Here are some TinySearch idioms that you should be using in your code. See solution for lab4 for many
examples.
<div 
class="colorbox" id="colorbox4"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK,</span><span 
class="cmtt-10">&#x00A0;BZERO</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;URLNODE*</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(URLNODE));</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(n);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;d;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;visited</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;BZERO(n-&#x003E;url,</span><span 
class="cmtt-10">&#x00A0;MAX_URL_LENGTH);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;LOG</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(page</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;LOG("CANNOT</span><span 
class="cmtt-10">&#x00A0;crawl</span><span 
class="cmtt-10">&#x00A0;seed</span><span 
class="cmtt-10">&#x00A0;page.</span><span 
class="cmtt-10">&#x00A0;Panic!");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;exit(-1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;ASSERT</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 191--><p class="noindent" >So write in idioms as much as possible; it limits bugs at boundaries.
<!--l. 193--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-8000"></a>TIP: Test code at its boundaries</h3>
<!--l. 195--><p class="noindent" >In what follows, we use a series of code snippets from [KP, 1999] to illustrate how to code to remove
boundary bugs. It is a simple yet elegant example of writing code to handle all the boundary conditions
that may present themselves.
                                                                                  
                                                                                  
<!--l. 197--><p class="noindent" >Boundary testing assumes you test a small snippet of code at a time - sort of micro testing of code
sequences or what should be idiomatic code. The example code does not use idioms and is poorly written
to cater for boundary bugs. It is set up to illustrate that. But we have all written poor code like this. The
take home from this section is how the code evolves once we think about where the boundary bugs
are. So, for example, as you write a loop of some sort check there and then that condition
branches the right way or that execution would go through the loop the correct number of
times.
<!--l. 199--><p class="noindent" >The technique is called <span 
class="cmbx-10">boundary condition testing </span>because you probe at the natural boundaries of the
program, its data and its data structures (if they exist). For example, for the code below we probe for the
following boundaries:
<!--l. 201--><p class="noindent" >1) empty input <br 
class="newline" />2) a single input character <br 
class="newline" />3) an exactly full array - but could be malloced buffer <br 
class="newline" />
<!--l. 205--><p class="noindent" >and so on. It could have been
<!--l. 207--><p class="noindent" >4) empty queue <br 
class="newline" />5) no collisions in a hash table <br 
class="newline" />6) collisions in a hash table <br 
class="newline" />7) add to the end of a cluster, etc.<br 
class="newline" />
<!--l. 212--><p class="noindent" >Consider the following code snippet from [KP, 1999]:
<!--l. 214--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-9000"></a>BOUNDARY TEST: Empty Input with only newline character</h3>
<div 
class="colorbox" id="colorbox5"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;(s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;&amp;&amp;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;++i)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;;</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;do</span><span 
class="cmtt-10">&#x00A0;nothing</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[--i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 234--><p class="noindent" >Looking at this code the first thing that should strike us is that it&#347; not a C idiom. That should make us
look very closely at the loop logic; particularly, the loops conditional logic. Maybe, after studying the code
thinking about characters being input we convince ourselves that the code is non idiomatic but works.
Now start to test boundaries. Consider 1) above where there is no input but a newline - the user simply
types carriage return for example. The resulting code would terminate immediately on the
first iteration with i set to zero. The last line that should replace a newline character with
a end of string character writes NULL to s[i-1], which is before the start of the array. Not
a good idea hey. Thinking about a boundary test gets the pesky bug out into the open to
swat.
<!--l. 236--><p class="noindent" >Here is the nasty edge case code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/edgecases.c" > edgecases.c&#x00A0;</a>
                                                                                  
                                                                                  
<!--l. 241--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-10000"></a>BOUNDARY TEST: Empty Input with only EOF character</h3>
<!--l. 243--><p class="noindent" >OK. The smart thing to do is rewrite this convoluted loop as an idiom and solve the problem; for
example:
<div 
class="colorbox" id="colorbox6"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;note</span><span 
class="cmtt-10">&#x00A0;we</span><span 
class="cmtt-10">&#x00A0;switch</span><span 
class="cmtt-10">&#x00A0;++i</span><span 
class="cmtt-10">&#x00A0;=&#x003E;</span><span 
class="cmtt-10">&#x00A0;i++,</span><span 
class="cmtt-10">&#x00A0;the</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 264--><p class="noindent" >Inspecting the code above we can easily see that the previous boundary problem is solved with the
new idiomatic code. It handles the case when the input is solely a newline beautifully. If we
mentally compute through reading 1, 2 or 3 characters we see it also works; for example a b c <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\n</span></span></span>
works.
<!--l. 266--><p class="noindent" ><span 
class="cmbx-10">s[0] is a </span><br 
class="newline" /><span 
class="cmbx-10">s[1] is b </span><br 
class="newline" /><span 
class="cmbx-10">s[2] is c </span><br 
class="newline" /><span 
class="cmbx-10">s[3] is 0 </span><br 
class="newline" />
<!--l. 271--><p class="noindent" >Looks good.
<!--l. 273--><p class="noindent" >Here is the better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/better.c" > better.c&#x00A0;</a>
<!--l. 277--><p class="noindent" >But what if we get an empty line and the first characters is an EOF? It breaks. Another pesky bug in our
code. More specifically, we do not cater for an unexpected action, well at least in terms of the person that
coded the loop. Someone hitting control D (EOF) would be a likely occurrences, well a probabilistic
occurrence.
<!--l. 279--><p class="noindent" >OK. Let&#347; fix this boundary bug.
<div 
class="colorbox" id="colorbox7"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 300--><p class="noindent" >That works! Nice piece of code now. Looks like we are done.
<!--l. 302--><p class="noindent" >Here is the even better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/evenbetter.c" > evenbetter.c&#x00A0;</a>
<!--l. 306--><p class="noindent" >We have removed and tested all the edge cases. The code handles all the edge cases nicely
now.
<!--l. 308--><p class="noindent" >// - where the first character is newline
<!--l. 310--><p class="noindent" >// - where the first character is EOF
<!--l. 312--><p class="noindent" >// - where there is one character
<!--l. 314--><p class="noindent" >// - where there are more characters input than the max size of the array
<!--l. 316--><p class="noindent" >// - where characters are entered terminated by a newline
<!--l. 318--><p class="noindent" >// - where there are characters entered terminated by a EOF (control D)
<!--l. 322--><p class="noindent" >Em...are we sure. There are other boundary problems that could lurk here. What happens if the array is
nearly full - does it work? What happens if the array is exactly full? Or over full - what happens if any of
these conditions occur followed by a newline. Are these boundary conditions catered for? We will leave you
to determine the answer to that question.
                                                                                  
                                                                                  
<!--l. 324--><p class="noindent" ><span 
class="cmbx-10">You get the idea. Bugs lurk at boundaries. Conversely, if code works at boundaries it is</span>
<span 
class="cmbx-10">likely to work elsewhere</span>
<!--l. 326--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-11000"></a>TIP: Test pre and post conditions</h3>
<!--l. 328--><p class="noindent" >It is always a good idea to test for pre and post conditions - that is before and after, respectively, some
program executes. For example, we have already used defensive program to check input values are with in
range - an example of pre-condition testing. Let&#347; look at another simple example out of [KP, 1999] that
computes the average of n elements in an array a[]. Closer inspection of the code reveals that there is a
problem is n is less than or equal to 0.
<div 
class="colorbox" id="colorbox8"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /></div></div>
<!--l. 355--><p class="noindent" >A natural question is what to do if someone calls avg() with n=0? An array of zero elements does not
make much sense but an average of 0 does. Should our code catch the division by zero? with an assert, or
abort, or complain or be silent? One reasonable approach is to just return 0 as the average if n is less than
or equal to zero. While the code is idiomatic in style we need to tweak it to test pre-condition, as shown
below - note: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n</span></span></span>
<div 
class="colorbox" id="colorbox9"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 384--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-12000"></a>TIP: Use asserts or in the case of TinySearch MY_ASSERT()</h3>
<!--l. 386--><p class="noindent" >We have used MY_ASSERT() macros in the development of TinySearch and in the unit testing code with
SHOULD_BE(); for example:
<div 
class="colorbox" id="colorbox10"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;dictionary_test.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DICTIONARY*</span><span 
class="cmtt-10">&#x00A0;dict</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;InitDictionary();</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d1;</span><span 
class="cmtt-10">&#x00A0;d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d2;</span><span 
class="cmtt-10">&#x00A0;d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;2;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d1,</span><span 
class="cmtt-10">&#x00A0;"1");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d2,</span><span 
class="cmtt-10">&#x00A0;"2");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;end</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]-&#x003E;next);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;start</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d2);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;next</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;crawler.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;current_depth,</span><span 
class="cmtt-10">&#x00A0;max_depth;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;URLToBeVisited;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char**</span><span 
class="cmtt-10">&#x00A0;URLsLists;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;page;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;current_depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 425--><p class="noindent" >C provides an assertion facility in assert.h useful for pre and post condition testing. Asserts are
usually used for unexpected failure where there is no clean way to recover the logic control. For
example our avg() function could include a different solution then n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;</span></span></span>= 0 using the assert
function:
<div 
class="colorbox" id="colorbox11"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sume</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;assert(n</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;0);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 456--><p class="noindent" >If the assertion is in fact violated it will cause an abort and standard message to be printed
out:
<!--l. 458--><p class="noindent" >Assertion failed: n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003E;</span></span></span> 0, file avgtest.c, line 7 <br 
class="newline" />Abort(crash)<br 
class="newline" />
                                                                                  
                                                                                  
<!--l. 461--><p class="noindent" >Assertions are very useful in validating the expected properties of an interface or range of input
arguments.
<!--l. 464--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-13000"></a>TIP: Test for the unexpected: aka defensive programming</h3>
<!--l. 466--><p class="noindent" >Your crawler and indexer uses defensive programming for checking that the input arguments are logically
correct: e.g., that a path actually existed. But a useful technique when coding is to &#8220;expect the
unexpected&#8221; or code for the unexpected. Adding checks for n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x00A0;&#x003C;</span></span></span> 0 in avg() is an example. Another is
below:
<div 
class="colorbox" id="colorbox12"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;100}</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*can&#8217;t</span><span 
class="cmtt-10">&#x00A0;happen,</span><span 
class="cmtt-10">&#x00A0;well</span><span 
class="cmtt-10">&#x00A0;possibly,</span><span 
class="cmtt-10">&#x00A0;at</span><span 
class="cmtt-10">&#x00A0;Dartmouth</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;?&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;90)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;A&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><br /></div></div>
<!--l. 488--><p class="noindent" >The CS50 automatic grading program - a snippet is shown above ;-) handles negative grades (I<img 
src="artoftesting0x.png" alt="v  "  class="acute" >e yet to
do that) and very large grades. If the unexpected happens the code returns a ? This is a good example of
defensive programming. In essence our programmer is coding against incorrect use or illegal data. Other
examples include:
<!--l. 493--><p class="noindent" >1) Out of range subscripts <br 
class="newline" />2) NULL pointers <br 
class="newline" />3) Divide by zero <br 
class="newline" />
<!--l. 498--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-14000"></a>TIP: Always check error returns from functions</h3>
<!--l. 500--><p class="noindent" >A really good programmer will always check the return status from functions, system calls, and libraries. If
you neglect to look at the return status then how do you know that the function really worked. If your
code assumes it did not fail but it did then the segfault or error will be hard to debug. Better to always
check the error status returned by functions.
<!--l. 506--><p class="noindent" >Another example from [KP, 1996].
<div 
class="colorbox" id="colorbox13"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fp</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;fopen(outfile,</span><span 
class="cmtt-10">&#x00A0;&#8216;&#8216;w&#8217;&#8217;);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(some</span><span 
class="cmtt-10">&#x00A0;expression)</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;write</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;file*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fprintf(fp,</span><span 
class="cmtt-10">&#x00A0;...);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(fclose(fp)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><span 
class="cmtt-10">&#x00A0;{</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;check</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;errors</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;some</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;error</span><span 
class="cmtt-10">&#x00A0;occurred</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 527--><p class="noindent" >Output errors can be serious problem and if the file being written above fails and the error status not
checked on fprintf then the file data can be lost. But the check above will save you from removing the old
file if the new one was not written probably.
                                                                                  
                                                                                  
<!--l. 531--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-15000"></a>TIP: Others useful things to do</h3>
<!--l. 533--><p class="noindent" >1) Test incrementally and build confidence in your code. <br 
class="newline" />2) Write unit tests that can be re-run once fixes or changes have been made. <br 
class="newline" />3) Write self-contained unit tests <br 
class="newline" />3.1) Test inputs and outputs.<br 
class="newline" />3.2) Test the dataflow through the program. <br 
class="newline" />3.3) Test all the execution paths through the program. <br 
class="newline" />3.4) Question: what environment do you need to set up to do 3.1-3.3<br 
class="newline" />4) Stress test the code; start simple and advance (test crawler at depth 1 .. 10 for example).<br 
class="newline" />5) Don&#8217;t implement new features if there are known bugs in the system.<br 
class="newline" />6) Test for portability: run code and tests on multiple machines/OSs.<br 
class="newline" />7) Before shipping code make sure that the test code ifdefs are off.<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="cmbx-10">If you follow at least 50% of the tips in these notes you will write better code and it will</span>
<span 
class="cmbx-10">have considerably less bugs than if you did not apply these simple tips and strategy. Or your</span>
<span 
class="cmbx-10">money back.</span>
 
</body></html> 

                                                                                  


http://www.cs.dartmouth.edu/~campbell/cs50/artoftesting.html
Depth: 2
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="artoftesting.tex"> 
<meta name="date" content="2014-02-11 22:45:00"> 
<link rel="stylesheet" type="text/css" href="artoftesting.css"> 
</head><body 
>
<h1 class="likepartHead"><a 
 id="x1-1000"></a>CS 50 Software Design and Implementation</h1>
<h1 class="likepartHead"><a 
 id="x1-2000"></a>Lecture 17</h1>
<h1 class="likepartHead"><a 
 id="x1-3000"></a>The Art of Testing (and Writing Good Code)</h1>
<!--l. 21--><p class="noindent" >Edsger Dijkstra once said that testing can demonstrate the presence of bugs but not their absence. That is
good to keep in mind when you are developing code - good code. What is the difference between
debugging and testing? You debug when you know or have identified problems in your code. Testing is the
art of systematically trying to break code, which you think is bug free. In this lecture, we will deal with
the detective work needed to break code and try and uncover inconsistencies and problems with your
working code.
<!--l. 23--><p class="noindent" >In the next lecture, we will discuss how to automate unit testing - an extremely important part of the
design and development process. In these notes, we discuss neat strategies <span 
class="cmbx-10">such as test as you</span>
<span 
class="cmbx-10">code</span>; for example, many bugs exist at what we call <span 
class="cmbx-10">boundaries</span>: e.g., a program that reads
data up to the end of an allocated buffer; a program expecting a stream of characters gets a
newline or EOF character as the first character it reads; a for loop not written as a <span 
class="cmbx-10">C idiom</span>
attempts to write one memory location beyond the end of an array (C can be dangerous, for
example, it has no subscript checking). If you think about common bugs that could creep
into code while writing code then that could save you significant time in the development
process.
<!--l. 27--><p class="noindent" >The material used in the lecture is strongly influenced by: <span 
class="cmbx-10">[KP, 1999] </span>The Practice of Programming
(Addison-Wesley Professional Computing Series) by Brian W. Kernighan, Rob Pike. The notes use a
number of programming examples from Chapter 6 on Testing. The text also reflects and cites material
from that chapter. This is an outstanding book and strongly recommended to advance your knowledge on
good programming practices. We use some coded examples from [KP, 1999] as cited in the
notes.
<!--l. 29--><p class="noindent" >Another short reference I like is <a 
href="http://www.ibm.com/developerworks/library/j-test.html" >Jeff Canna&#8217;s &#8220;Testing, Fun, Really&#8221;</a>. I would recommend that you read
Chapter 6 from [KP, 1999] and Jeff Canna article.
<!--l. 31--><p class="noindent" >BTW, you can skip these notes if you write bug free code ;-)
<h3 class="likesectionHead"><a 
 id="x1-4000"></a>Goals</h3>
<!--l. 35--><p class="noindent" >We plan to learn the following from today&#8217;s lecture:
                                                                                  
                                                                                  
     <ul class="itemize1">
     <li class="itemize">I write bug free code - testing is a waste of time?
     </li>
     <li class="itemize">TIP: Test as you write code
     </li>
     <li class="itemize">TIP: Use C idioms and be consistent when you write code
     </li>
     <li class="itemize">TIP: Test code at its boundaries
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only newline <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#8217;\n&#8217;</span></span></span> character
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only EOF character
     </li>
     <li class="itemize">TIP: Use asserts or in the case of TinySearch MY_ASSERT()
     </li>
     <li class="itemize">TIP: Test pre and post conditions
     </li>
     <li class="itemize">TIP: Test for the unexpected: aka defensive programming
     </li>
     <li class="itemize">TIP: Always check error returns from functions
     </li>
     <li class="itemize">TIP: Others useful things to do</li></ul>
<!--l. 51--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-5000"></a>I write bug free code - testing is a waste of time?</h3>
<!--l. 53--><p class="noindent" >Many people have the attitude that testing code is a waste of time and boring - why do it? When one
considers the software lifecycle discussed in class: procurement, requirements, design, coding, testing,
debugging, integration and bake off then I would say that testing and debugging take the largest chuck of
time. It is smart to develop tools and code to automate the testing of code. Why do this? Well the simple
answer is it saves time and pushes the sometimes tedious task of testing into tools and away from humans.
Imagine you design and develop a complex system and sell it to a customer who subsequently finds a
serious bug out in the wild; that is to say, when the product is deployed in a power station, across a
country such as an air traffic control system, in washing machines, or an app. The point is that you
fix the problem but how do you know you haven&#8217;t broken something else while fixing your
serious bug? You don&#8217;t know unless you have developed a set of tools to systematic retest
the code. If you have developed a set of integration tests, sub-system tests and unit tests
then you can quickly rerun them before you reship the new product with the bug fix. If all
                                                                                  
                                                                                  
the tests pass then you have some confidence that the change you made did not introduce
additional problems. Note, I use the phase &#8220;some confidence&#8221; because you are never 100%
sure.
<!--l. 55--><p class="noindent" >Let me restate the difference between debugging and testing again - with some philosophical comments. It
is good to have that clear in your mind:
<!--l. 57--><p class="noindent" ><span 
class="cmbx-10">Testing </span>is a determined, systematic attempt to break a program that you think is working. As discussed
above, putting smarts into the development of a set of tools and test harness can automate this process.
Story: this lecturer started his software career working for a company called Plessey Radar in
the UK. His first assignment was testing someone else code. Fortunately, this was very cool
because the code under test was the kernel of an Operating System. I did applied math at
university and knew nothing about software. It might have felt like grunt work to a newbie
on the job but I learnt how to design an operating system from the ground up. Later in my
career I worked for company that brought in a consultant to run integration tests again code -
my code. I was not happy dealing with testers until they found bugs in my code that was
already under beta release. After that I had time and respect for them. Today, I still think
producing smart testing tools to automate the testing of your code produces much more robust
code.
<!--l. 59--><p class="noindent" ><span 
class="cmbx-10">Debugging </span>is what you do when you know that the program is broken (e.g., segfault), fails (e.g.,
DDNODE is never linked into the hash table), underperforms (e.g., the memory leaks bring
the system to a slow but grinding halt) or acts inconsistently (e.g., never terminates when it
should). These are all bugs that testing can find. Better to find them and fix them. Sometimes
bugs cascade, i.e., one bug creates others and so on. These types of bugs are hard to fix. In
essence, the &#8220;bug chain&#8221; needs to be worked through to get to the real culprit at the start of
the chain. Many times it is not obvious what problems in a system are linked and therefore
requires some detective work: in the last lecture we <span 
class="cmbx-10">forced the bug out into the open</span>
before swatting that pesky bug - which, you recall, lurked at the boundary of the for loop
logic.
<!--l. 61--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-6000"></a>TIP: Test as you write code</h3>
<!--l. 63--><p class="noindent" >The earlier you find a problem with your code the better; it will save significant time and your company
money. You will also get respect from other programmers. Digging bugs out months after you have written
and forgotten the code is a serious challenge: test as you go. I know that for most labs you have sat a the
terminal and just hacked at the code to reveal and fix bugs - you sit there praying, hacking some
printfs and hit make and them run your code: you are doing this 100s of times. It is not a
smart to work like this and represents a dumb brute force method - you&#8217;ll get no respect in
industry for that. So be smart add a couple of new skills to your cs50 toolbox: &#8220;test as you go is
one&#8221;. Using C idioms is another great way to limit bugs; for example, if you do not blindly
hack code but enter code and sit back for a moment and read that while or for loop logic
through carefully then you have already tested your code on one level before you have hit
the gcc button. Doesn&#8217;t this make good sense? Yes, it does make good sense and having put
                                                                                  
                                                                                  
your code through inspection before you compile it is great, really great, and it comes for
free.
<!--l. 65--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-7000"></a>TIP: Use C idioms and be consistent when you write code</h3>
<!--l. 67--><p class="noindent" >You already know many C idioms even if we haven&#8217;t always labeled them that way. But there are many
ways to write a simple loop for example:
<div 
class="colorbox" id="colorbox1"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;first</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;&#x003C;=</span><span 
class="cmtt-10">&#x00A0;n-1)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;next</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;final</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;--i</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div></div>
<!--l. 97--><p class="noindent" >There are many ways to skin a cat - that is horrible saying, right and my cat Tiger would be alarmed. The
simple loop is developed in three different ways. But like the English language the C programming
language has idioms: where idiom means: <span 
class="cmbx-10">C idioms are conventional ways that experienced</span>
<span 
class="cmbx-10">programmers write common pieces of code. A central part of any language is developing</span>
<span 
class="cmbx-10">familiarity with its idioms </span>[KP, 1999].
<!--l. 102--><p class="noindent" >While all of the loops shown above would work they are not C idioms. The C idiom is:
<div 
class="colorbox" id="colorbox2"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Idiomatic</span><span 
class="cmtt-10">&#x00A0;form</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div>                 </div>
<!--l. 118--><p class="noindent" >Being consistent when programming C will help enormously. For example, if you are use to writing
idiomatic code then when you see a piece of code that is not idiomatic you should stop and take a close
look at that code: maybe a boundary problem is more likely? If code is written the same way each time
then when you see code that is not idiomatic it either suggests poor code or some genuine difference exists
that the idiom does not cover. Either way: take a second close look to convince yourself its one or the
other.
<!--l. 121--><p class="noindent" >Here are some more examples of C idioms that you should be familiar with:
<div 
class="colorbox" id="colorbox3"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Infinite</span><span 
class="cmtt-10">&#x00A0;loop</span><span 
class="cmtt-10">&#x00A0;idioms</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(;;)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;or</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(1)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;string</span><span 
class="cmtt-10">&#x00A0;copy</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;p</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(strlen(buf)+1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(p);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;strcpy(p,</span><span 
class="cmtt-10">&#x00A0;buf);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;reading</span><span 
class="cmtt-10">&#x00A0;in</span><span 
class="cmtt-10">&#x00A0;and</span><span 
class="cmtt-10">&#x00A0;writing</span><span 
class="cmtt-10">&#x00A0;out</span><span 
class="cmtt-10">&#x00A0;characters</span><span 
class="cmtt-10">&#x00A0;until</span><span 
class="cmtt-10">&#x00A0;EOF</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;((c</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;putchar(c);</span><br /><br /></div></div>
<!--l. 160--><p class="noindent" >Here are some TinySearch idioms that you should be using in your code. See solution for lab4 for many
examples.
<div 
class="colorbox" id="colorbox4"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK,</span><span 
class="cmtt-10">&#x00A0;BZERO</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;URLNODE*</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(URLNODE));</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(n);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;d;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;visited</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;BZERO(n-&#x003E;url,</span><span 
class="cmtt-10">&#x00A0;MAX_URL_LENGTH);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;LOG</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(page</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;LOG("CANNOT</span><span 
class="cmtt-10">&#x00A0;crawl</span><span 
class="cmtt-10">&#x00A0;seed</span><span 
class="cmtt-10">&#x00A0;page.</span><span 
class="cmtt-10">&#x00A0;Panic!");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;exit(-1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;ASSERT</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 191--><p class="noindent" >So write in idioms as much as possible; it limits bugs at boundaries.
<!--l. 193--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-8000"></a>TIP: Test code at its boundaries</h3>
<!--l. 195--><p class="noindent" >In what follows, we use a series of code snippets from [KP, 1999] to illustrate how to code to remove
boundary bugs. It is a simple yet elegant example of writing code to handle all the boundary conditions
that may present themselves.
                                                                                  
                                                                                  
<!--l. 197--><p class="noindent" >Boundary testing assumes you test a small snippet of code at a time - sort of micro testing of code
sequences or what should be idiomatic code. The example code does not use idioms and is poorly written
to cater for boundary bugs. It is set up to illustrate that. But we have all written poor code like this. The
take home from this section is how the code evolves once we think about where the boundary bugs
are. So, for example, as you write a loop of some sort check there and then that condition
branches the right way or that execution would go through the loop the correct number of
times.
<!--l. 199--><p class="noindent" >The technique is called <span 
class="cmbx-10">boundary condition testing </span>because you probe at the natural boundaries of the
program, its data and its data structures (if they exist). For example, for the code below we probe for the
following boundaries:
<!--l. 201--><p class="noindent" >1) empty input <br 
class="newline" />2) a single input character <br 
class="newline" />3) an exactly full array - but could be malloced buffer <br 
class="newline" />
<!--l. 205--><p class="noindent" >and so on. It could have been
<!--l. 207--><p class="noindent" >4) empty queue <br 
class="newline" />5) no collisions in a hash table <br 
class="newline" />6) collisions in a hash table <br 
class="newline" />7) add to the end of a cluster, etc.<br 
class="newline" />
<!--l. 212--><p class="noindent" >Consider the following code snippet from [KP, 1999]:
<!--l. 214--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-9000"></a>BOUNDARY TEST: Empty Input with only newline character</h3>
<div 
class="colorbox" id="colorbox5"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;(s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;&amp;&amp;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;++i)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;;</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;do</span><span 
class="cmtt-10">&#x00A0;nothing</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[--i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 234--><p class="noindent" >Looking at this code the first thing that should strike us is that it&#347; not a C idiom. That should make us
look very closely at the loop logic; particularly, the loops conditional logic. Maybe, after studying the code
thinking about characters being input we convince ourselves that the code is non idiomatic but works.
Now start to test boundaries. Consider 1) above where there is no input but a newline - the user simply
types carriage return for example. The resulting code would terminate immediately on the
first iteration with i set to zero. The last line that should replace a newline character with
a end of string character writes NULL to s[i-1], which is before the start of the array. Not
a good idea hey. Thinking about a boundary test gets the pesky bug out into the open to
swat.
<!--l. 236--><p class="noindent" >Here is the nasty edge case code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/edgecases.c" > edgecases.c&#x00A0;</a>
                                                                                  
                                                                                  
<!--l. 241--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-10000"></a>BOUNDARY TEST: Empty Input with only EOF character</h3>
<!--l. 243--><p class="noindent" >OK. The smart thing to do is rewrite this convoluted loop as an idiom and solve the problem; for
example:
<div 
class="colorbox" id="colorbox6"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;note</span><span 
class="cmtt-10">&#x00A0;we</span><span 
class="cmtt-10">&#x00A0;switch</span><span 
class="cmtt-10">&#x00A0;++i</span><span 
class="cmtt-10">&#x00A0;=&#x003E;</span><span 
class="cmtt-10">&#x00A0;i++,</span><span 
class="cmtt-10">&#x00A0;the</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 264--><p class="noindent" >Inspecting the code above we can easily see that the previous boundary problem is solved with the
new idiomatic code. It handles the case when the input is solely a newline beautifully. If we
mentally compute through reading 1, 2 or 3 characters we see it also works; for example a b c <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\n</span></span></span>
works.
<!--l. 266--><p class="noindent" ><span 
class="cmbx-10">s[0] is a </span><br 
class="newline" /><span 
class="cmbx-10">s[1] is b </span><br 
class="newline" /><span 
class="cmbx-10">s[2] is c </span><br 
class="newline" /><span 
class="cmbx-10">s[3] is 0 </span><br 
class="newline" />
<!--l. 271--><p class="noindent" >Looks good.
<!--l. 273--><p class="noindent" >Here is the better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/better.c" > better.c&#x00A0;</a>
<!--l. 277--><p class="noindent" >But what if we get an empty line and the first characters is an EOF? It breaks. Another pesky bug in our
code. More specifically, we do not cater for an unexpected action, well at least in terms of the person that
coded the loop. Someone hitting control D (EOF) would be a likely occurrences, well a probabilistic
occurrence.
<!--l. 279--><p class="noindent" >OK. Let&#347; fix this boundary bug.
<div 
class="colorbox" id="colorbox7"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 300--><p class="noindent" >That works! Nice piece of code now. Looks like we are done.
<!--l. 302--><p class="noindent" >Here is the even better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/evenbetter.c" > evenbetter.c&#x00A0;</a>
<!--l. 306--><p class="noindent" >We have removed and tested all the edge cases. The code handles all the edge cases nicely
now.
<!--l. 308--><p class="noindent" >// - where the first character is newline
<!--l. 310--><p class="noindent" >// - where the first character is EOF
<!--l. 312--><p class="noindent" >// - where there is one character
<!--l. 314--><p class="noindent" >// - where there are more characters input than the max size of the array
<!--l. 316--><p class="noindent" >// - where characters are entered terminated by a newline
<!--l. 318--><p class="noindent" >// - where there are characters entered terminated by a EOF (control D)
<!--l. 322--><p class="noindent" >Em...are we sure. There are other boundary problems that could lurk here. What happens if the array is
nearly full - does it work? What happens if the array is exactly full? Or over full - what happens if any of
these conditions occur followed by a newline. Are these boundary conditions catered for? We will leave you
to determine the answer to that question.
                                                                                  
                                                                                  
<!--l. 324--><p class="noindent" ><span 
class="cmbx-10">You get the idea. Bugs lurk at boundaries. Conversely, if code works at boundaries it is</span>
<span 
class="cmbx-10">likely to work elsewhere</span>
<!--l. 326--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-11000"></a>TIP: Test pre and post conditions</h3>
<!--l. 328--><p class="noindent" >It is always a good idea to test for pre and post conditions - that is before and after, respectively, some
program executes. For example, we have already used defensive program to check input values are with in
range - an example of pre-condition testing. Let&#347; look at another simple example out of [KP, 1999] that
computes the average of n elements in an array a[]. Closer inspection of the code reveals that there is a
problem is n is less than or equal to 0.
<div 
class="colorbox" id="colorbox8"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /></div></div>
<!--l. 355--><p class="noindent" >A natural question is what to do if someone calls avg() with n=0? An array of zero elements does not
make much sense but an average of 0 does. Should our code catch the division by zero? with an assert, or
abort, or complain or be silent? One reasonable approach is to just return 0 as the average if n is less than
or equal to zero. While the code is idiomatic in style we need to tweak it to test pre-condition, as shown
below - note: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n</span></span></span>
<div 
class="colorbox" id="colorbox9"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 384--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-12000"></a>TIP: Use asserts or in the case of TinySearch MY_ASSERT()</h3>
<!--l. 386--><p class="noindent" >We have used MY_ASSERT() macros in the development of TinySearch and in the unit testing code with
SHOULD_BE(); for example:
<div 
class="colorbox" id="colorbox10"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;dictionary_test.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DICTIONARY*</span><span 
class="cmtt-10">&#x00A0;dict</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;InitDictionary();</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d1;</span><span 
class="cmtt-10">&#x00A0;d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d2;</span><span 
class="cmtt-10">&#x00A0;d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;2;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d1,</span><span 
class="cmtt-10">&#x00A0;"1");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d2,</span><span 
class="cmtt-10">&#x00A0;"2");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;end</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]-&#x003E;next);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;start</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d2);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;next</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;crawler.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;current_depth,</span><span 
class="cmtt-10">&#x00A0;max_depth;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;URLToBeVisited;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char**</span><span 
class="cmtt-10">&#x00A0;URLsLists;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;page;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;current_depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 425--><p class="noindent" >C provides an assertion facility in assert.h useful for pre and post condition testing. Asserts are
usually used for unexpected failure where there is no clean way to recover the logic control. For
example our avg() function could include a different solution then n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;</span></span></span>= 0 using the assert
function:
<div 
class="colorbox" id="colorbox11"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sume</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;assert(n</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;0);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 456--><p class="noindent" >If the assertion is in fact violated it will cause an abort and standard message to be printed
out:
<!--l. 458--><p class="noindent" >Assertion failed: n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003E;</span></span></span> 0, file avgtest.c, line 7 <br 
class="newline" />Abort(crash)<br 
class="newline" />
                                                                                  
                                                                                  
<!--l. 461--><p class="noindent" >Assertions are very useful in validating the expected properties of an interface or range of input
arguments.
<!--l. 464--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-13000"></a>TIP: Test for the unexpected: aka defensive programming</h3>
<!--l. 466--><p class="noindent" >Your crawler and indexer uses defensive programming for checking that the input arguments are logically
correct: e.g., that a path actually existed. But a useful technique when coding is to &#8220;expect the
unexpected&#8221; or code for the unexpected. Adding checks for n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x00A0;&#x003C;</span></span></span> 0 in avg() is an example. Another is
below:
<div 
class="colorbox" id="colorbox12"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;100}</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*can&#8217;t</span><span 
class="cmtt-10">&#x00A0;happen,</span><span 
class="cmtt-10">&#x00A0;well</span><span 
class="cmtt-10">&#x00A0;possibly,</span><span 
class="cmtt-10">&#x00A0;at</span><span 
class="cmtt-10">&#x00A0;Dartmouth</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;?&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;90)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;A&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><br /></div></div>
<!--l. 488--><p class="noindent" >The CS50 automatic grading program - a snippet is shown above ;-) handles negative grades (I<img 
src="artoftesting0x.png" alt="v  "  class="acute" >e yet to
do that) and very large grades. If the unexpected happens the code returns a ? This is a good example of
defensive programming. In essence our programmer is coding against incorrect use or illegal data. Other
examples include:
<!--l. 493--><p class="noindent" >1) Out of range subscripts <br 
class="newline" />2) NULL pointers <br 
class="newline" />3) Divide by zero <br 
class="newline" />
<!--l. 498--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-14000"></a>TIP: Always check error returns from functions</h3>
<!--l. 500--><p class="noindent" >A really good programmer will always check the return status from functions, system calls, and libraries. If
you neglect to look at the return status then how do you know that the function really worked. If your
code assumes it did not fail but it did then the segfault or error will be hard to debug. Better to always
check the error status returned by functions.
<!--l. 506--><p class="noindent" >Another example from [KP, 1996].
<div 
class="colorbox" id="colorbox13"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fp</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;fopen(outfile,</span><span 
class="cmtt-10">&#x00A0;&#8216;&#8216;w&#8217;&#8217;);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(some</span><span 
class="cmtt-10">&#x00A0;expression)</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;write</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;file*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fprintf(fp,</span><span 
class="cmtt-10">&#x00A0;...);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(fclose(fp)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><span 
class="cmtt-10">&#x00A0;{</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;check</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;errors</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;some</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;error</span><span 
class="cmtt-10">&#x00A0;occurred</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 527--><p class="noindent" >Output errors can be serious problem and if the file being written above fails and the error status not
checked on fprintf then the file data can be lost. But the check above will save you from removing the old
file if the new one was not written probably.
                                                                                  
                                                                                  
<!--l. 531--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-15000"></a>TIP: Others useful things to do</h3>
<!--l. 533--><p class="noindent" >1) Test incrementally and build confidence in your code. <br 
class="newline" />2) Write unit tests that can be re-run once fixes or changes have been made. <br 
class="newline" />3) Write self-contained unit tests <br 
class="newline" />3.1) Test inputs and outputs.<br 
class="newline" />3.2) Test the dataflow through the program. <br 
class="newline" />3.3) Test all the execution paths through the program. <br 
class="newline" />3.4) Question: what environment do you need to set up to do 3.1-3.3<br 
class="newline" />4) Stress test the code; start simple and advance (test crawler at depth 1 .. 10 for example).<br 
class="newline" />5) Don&#8217;t implement new features if there are known bugs in the system.<br 
class="newline" />6) Test for portability: run code and tests on multiple machines/OSs.<br 
class="newline" />7) Before shipping code make sure that the test code ifdefs are off.<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="cmbx-10">If you follow at least 50% of the tips in these notes you will write better code and it will</span>
<span 
class="cmbx-10">have considerably less bugs than if you did not apply these simple tips and strategy. Or your</span>
<span 
class="cmbx-10">money back.</span>
 
</body></html> 

                                                                                  


http://www.cs.dartmouth.edu/~campbell/cs50/artoftesting.html
Depth: 2
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="artoftesting.tex"> 
<meta name="date" content="2014-02-11 22:45:00"> 
<link rel="stylesheet" type="text/css" href="artoftesting.css"> 
</head><body 
>
<h1 class="likepartHead"><a 
 id="x1-1000"></a>CS 50 Software Design and Implementation</h1>
<h1 class="likepartHead"><a 
 id="x1-2000"></a>Lecture 17</h1>
<h1 class="likepartHead"><a 
 id="x1-3000"></a>The Art of Testing (and Writing Good Code)</h1>
<!--l. 21--><p class="noindent" >Edsger Dijkstra once said that testing can demonstrate the presence of bugs but not their absence. That is
good to keep in mind when you are developing code - good code. What is the difference between
debugging and testing? You debug when you know or have identified problems in your code. Testing is the
art of systematically trying to break code, which you think is bug free. In this lecture, we will deal with
the detective work needed to break code and try and uncover inconsistencies and problems with your
working code.
<!--l. 23--><p class="noindent" >In the next lecture, we will discuss how to automate unit testing - an extremely important part of the
design and development process. In these notes, we discuss neat strategies <span 
class="cmbx-10">such as test as you</span>
<span 
class="cmbx-10">code</span>; for example, many bugs exist at what we call <span 
class="cmbx-10">boundaries</span>: e.g., a program that reads
data up to the end of an allocated buffer; a program expecting a stream of characters gets a
newline or EOF character as the first character it reads; a for loop not written as a <span 
class="cmbx-10">C idiom</span>
attempts to write one memory location beyond the end of an array (C can be dangerous, for
example, it has no subscript checking). If you think about common bugs that could creep
into code while writing code then that could save you significant time in the development
process.
<!--l. 27--><p class="noindent" >The material used in the lecture is strongly influenced by: <span 
class="cmbx-10">[KP, 1999] </span>The Practice of Programming
(Addison-Wesley Professional Computing Series) by Brian W. Kernighan, Rob Pike. The notes use a
number of programming examples from Chapter 6 on Testing. The text also reflects and cites material
from that chapter. This is an outstanding book and strongly recommended to advance your knowledge on
good programming practices. We use some coded examples from [KP, 1999] as cited in the
notes.
<!--l. 29--><p class="noindent" >Another short reference I like is <a 
href="http://www.ibm.com/developerworks/library/j-test.html" >Jeff Canna&#8217;s &#8220;Testing, Fun, Really&#8221;</a>. I would recommend that you read
Chapter 6 from [KP, 1999] and Jeff Canna article.
<!--l. 31--><p class="noindent" >BTW, you can skip these notes if you write bug free code ;-)
<h3 class="likesectionHead"><a 
 id="x1-4000"></a>Goals</h3>
<!--l. 35--><p class="noindent" >We plan to learn the following from today&#8217;s lecture:
                                                                                  
                                                                                  
     <ul class="itemize1">
     <li class="itemize">I write bug free code - testing is a waste of time?
     </li>
     <li class="itemize">TIP: Test as you write code
     </li>
     <li class="itemize">TIP: Use C idioms and be consistent when you write code
     </li>
     <li class="itemize">TIP: Test code at its boundaries
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only newline <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#8217;\n&#8217;</span></span></span> character
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only EOF character
     </li>
     <li class="itemize">TIP: Use asserts or in the case of TinySearch MY_ASSERT()
     </li>
     <li class="itemize">TIP: Test pre and post conditions
     </li>
     <li class="itemize">TIP: Test for the unexpected: aka defensive programming
     </li>
     <li class="itemize">TIP: Always check error returns from functions
     </li>
     <li class="itemize">TIP: Others useful things to do</li></ul>
<!--l. 51--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-5000"></a>I write bug free code - testing is a waste of time?</h3>
<!--l. 53--><p class="noindent" >Many people have the attitude that testing code is a waste of time and boring - why do it? When one
considers the software lifecycle discussed in class: procurement, requirements, design, coding, testing,
debugging, integration and bake off then I would say that testing and debugging take the largest chuck of
time. It is smart to develop tools and code to automate the testing of code. Why do this? Well the simple
answer is it saves time and pushes the sometimes tedious task of testing into tools and away from humans.
Imagine you design and develop a complex system and sell it to a customer who subsequently finds a
serious bug out in the wild; that is to say, when the product is deployed in a power station, across a
country such as an air traffic control system, in washing machines, or an app. The point is that you
fix the problem but how do you know you haven&#8217;t broken something else while fixing your
serious bug? You don&#8217;t know unless you have developed a set of tools to systematic retest
the code. If you have developed a set of integration tests, sub-system tests and unit tests
then you can quickly rerun them before you reship the new product with the bug fix. If all
                                                                                  
                                                                                  
the tests pass then you have some confidence that the change you made did not introduce
additional problems. Note, I use the phase &#8220;some confidence&#8221; because you are never 100%
sure.
<!--l. 55--><p class="noindent" >Let me restate the difference between debugging and testing again - with some philosophical comments. It
is good to have that clear in your mind:
<!--l. 57--><p class="noindent" ><span 
class="cmbx-10">Testing </span>is a determined, systematic attempt to break a program that you think is working. As discussed
above, putting smarts into the development of a set of tools and test harness can automate this process.
Story: this lecturer started his software career working for a company called Plessey Radar in
the UK. His first assignment was testing someone else code. Fortunately, this was very cool
because the code under test was the kernel of an Operating System. I did applied math at
university and knew nothing about software. It might have felt like grunt work to a newbie
on the job but I learnt how to design an operating system from the ground up. Later in my
career I worked for company that brought in a consultant to run integration tests again code -
my code. I was not happy dealing with testers until they found bugs in my code that was
already under beta release. After that I had time and respect for them. Today, I still think
producing smart testing tools to automate the testing of your code produces much more robust
code.
<!--l. 59--><p class="noindent" ><span 
class="cmbx-10">Debugging </span>is what you do when you know that the program is broken (e.g., segfault), fails (e.g.,
DDNODE is never linked into the hash table), underperforms (e.g., the memory leaks bring
the system to a slow but grinding halt) or acts inconsistently (e.g., never terminates when it
should). These are all bugs that testing can find. Better to find them and fix them. Sometimes
bugs cascade, i.e., one bug creates others and so on. These types of bugs are hard to fix. In
essence, the &#8220;bug chain&#8221; needs to be worked through to get to the real culprit at the start of
the chain. Many times it is not obvious what problems in a system are linked and therefore
requires some detective work: in the last lecture we <span 
class="cmbx-10">forced the bug out into the open</span>
before swatting that pesky bug - which, you recall, lurked at the boundary of the for loop
logic.
<!--l. 61--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-6000"></a>TIP: Test as you write code</h3>
<!--l. 63--><p class="noindent" >The earlier you find a problem with your code the better; it will save significant time and your company
money. You will also get respect from other programmers. Digging bugs out months after you have written
and forgotten the code is a serious challenge: test as you go. I know that for most labs you have sat a the
terminal and just hacked at the code to reveal and fix bugs - you sit there praying, hacking some
printfs and hit make and them run your code: you are doing this 100s of times. It is not a
smart to work like this and represents a dumb brute force method - you&#8217;ll get no respect in
industry for that. So be smart add a couple of new skills to your cs50 toolbox: &#8220;test as you go is
one&#8221;. Using C idioms is another great way to limit bugs; for example, if you do not blindly
hack code but enter code and sit back for a moment and read that while or for loop logic
through carefully then you have already tested your code on one level before you have hit
the gcc button. Doesn&#8217;t this make good sense? Yes, it does make good sense and having put
                                                                                  
                                                                                  
your code through inspection before you compile it is great, really great, and it comes for
free.
<!--l. 65--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-7000"></a>TIP: Use C idioms and be consistent when you write code</h3>
<!--l. 67--><p class="noindent" >You already know many C idioms even if we haven&#8217;t always labeled them that way. But there are many
ways to write a simple loop for example:
<div 
class="colorbox" id="colorbox1"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;first</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;&#x003C;=</span><span 
class="cmtt-10">&#x00A0;n-1)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;next</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;final</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;--i</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div></div>
<!--l. 97--><p class="noindent" >There are many ways to skin a cat - that is horrible saying, right and my cat Tiger would be alarmed. The
simple loop is developed in three different ways. But like the English language the C programming
language has idioms: where idiom means: <span 
class="cmbx-10">C idioms are conventional ways that experienced</span>
<span 
class="cmbx-10">programmers write common pieces of code. A central part of any language is developing</span>
<span 
class="cmbx-10">familiarity with its idioms </span>[KP, 1999].
<!--l. 102--><p class="noindent" >While all of the loops shown above would work they are not C idioms. The C idiom is:
<div 
class="colorbox" id="colorbox2"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Idiomatic</span><span 
class="cmtt-10">&#x00A0;form</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div>                 </div>
<!--l. 118--><p class="noindent" >Being consistent when programming C will help enormously. For example, if you are use to writing
idiomatic code then when you see a piece of code that is not idiomatic you should stop and take a close
look at that code: maybe a boundary problem is more likely? If code is written the same way each time
then when you see code that is not idiomatic it either suggests poor code or some genuine difference exists
that the idiom does not cover. Either way: take a second close look to convince yourself its one or the
other.
<!--l. 121--><p class="noindent" >Here are some more examples of C idioms that you should be familiar with:
<div 
class="colorbox" id="colorbox3"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Infinite</span><span 
class="cmtt-10">&#x00A0;loop</span><span 
class="cmtt-10">&#x00A0;idioms</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(;;)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;or</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(1)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;string</span><span 
class="cmtt-10">&#x00A0;copy</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;p</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(strlen(buf)+1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(p);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;strcpy(p,</span><span 
class="cmtt-10">&#x00A0;buf);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;reading</span><span 
class="cmtt-10">&#x00A0;in</span><span 
class="cmtt-10">&#x00A0;and</span><span 
class="cmtt-10">&#x00A0;writing</span><span 
class="cmtt-10">&#x00A0;out</span><span 
class="cmtt-10">&#x00A0;characters</span><span 
class="cmtt-10">&#x00A0;until</span><span 
class="cmtt-10">&#x00A0;EOF</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;((c</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;putchar(c);</span><br /><br /></div></div>
<!--l. 160--><p class="noindent" >Here are some TinySearch idioms that you should be using in your code. See solution for lab4 for many
examples.
<div 
class="colorbox" id="colorbox4"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK,</span><span 
class="cmtt-10">&#x00A0;BZERO</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;URLNODE*</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(URLNODE));</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(n);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;d;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;visited</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;BZERO(n-&#x003E;url,</span><span 
class="cmtt-10">&#x00A0;MAX_URL_LENGTH);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;LOG</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(page</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;LOG("CANNOT</span><span 
class="cmtt-10">&#x00A0;crawl</span><span 
class="cmtt-10">&#x00A0;seed</span><span 
class="cmtt-10">&#x00A0;page.</span><span 
class="cmtt-10">&#x00A0;Panic!");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;exit(-1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;ASSERT</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 191--><p class="noindent" >So write in idioms as much as possible; it limits bugs at boundaries.
<!--l. 193--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-8000"></a>TIP: Test code at its boundaries</h3>
<!--l. 195--><p class="noindent" >In what follows, we use a series of code snippets from [KP, 1999] to illustrate how to code to remove
boundary bugs. It is a simple yet elegant example of writing code to handle all the boundary conditions
that may present themselves.
                                                                                  
                                                                                  
<!--l. 197--><p class="noindent" >Boundary testing assumes you test a small snippet of code at a time - sort of micro testing of code
sequences or what should be idiomatic code. The example code does not use idioms and is poorly written
to cater for boundary bugs. It is set up to illustrate that. But we have all written poor code like this. The
take home from this section is how the code evolves once we think about where the boundary bugs
are. So, for example, as you write a loop of some sort check there and then that condition
branches the right way or that execution would go through the loop the correct number of
times.
<!--l. 199--><p class="noindent" >The technique is called <span 
class="cmbx-10">boundary condition testing </span>because you probe at the natural boundaries of the
program, its data and its data structures (if they exist). For example, for the code below we probe for the
following boundaries:
<!--l. 201--><p class="noindent" >1) empty input <br 
class="newline" />2) a single input character <br 
class="newline" />3) an exactly full array - but could be malloced buffer <br 
class="newline" />
<!--l. 205--><p class="noindent" >and so on. It could have been
<!--l. 207--><p class="noindent" >4) empty queue <br 
class="newline" />5) no collisions in a hash table <br 
class="newline" />6) collisions in a hash table <br 
class="newline" />7) add to the end of a cluster, etc.<br 
class="newline" />
<!--l. 212--><p class="noindent" >Consider the following code snippet from [KP, 1999]:
<!--l. 214--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-9000"></a>BOUNDARY TEST: Empty Input with only newline character</h3>
<div 
class="colorbox" id="colorbox5"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;(s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;&amp;&amp;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;++i)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;;</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;do</span><span 
class="cmtt-10">&#x00A0;nothing</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[--i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 234--><p class="noindent" >Looking at this code the first thing that should strike us is that it&#347; not a C idiom. That should make us
look very closely at the loop logic; particularly, the loops conditional logic. Maybe, after studying the code
thinking about characters being input we convince ourselves that the code is non idiomatic but works.
Now start to test boundaries. Consider 1) above where there is no input but a newline - the user simply
types carriage return for example. The resulting code would terminate immediately on the
first iteration with i set to zero. The last line that should replace a newline character with
a end of string character writes NULL to s[i-1], which is before the start of the array. Not
a good idea hey. Thinking about a boundary test gets the pesky bug out into the open to
swat.
<!--l. 236--><p class="noindent" >Here is the nasty edge case code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/edgecases.c" > edgecases.c&#x00A0;</a>
                                                                                  
                                                                                  
<!--l. 241--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-10000"></a>BOUNDARY TEST: Empty Input with only EOF character</h3>
<!--l. 243--><p class="noindent" >OK. The smart thing to do is rewrite this convoluted loop as an idiom and solve the problem; for
example:
<div 
class="colorbox" id="colorbox6"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;note</span><span 
class="cmtt-10">&#x00A0;we</span><span 
class="cmtt-10">&#x00A0;switch</span><span 
class="cmtt-10">&#x00A0;++i</span><span 
class="cmtt-10">&#x00A0;=&#x003E;</span><span 
class="cmtt-10">&#x00A0;i++,</span><span 
class="cmtt-10">&#x00A0;the</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 264--><p class="noindent" >Inspecting the code above we can easily see that the previous boundary problem is solved with the
new idiomatic code. It handles the case when the input is solely a newline beautifully. If we
mentally compute through reading 1, 2 or 3 characters we see it also works; for example a b c <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\n</span></span></span>
works.
<!--l. 266--><p class="noindent" ><span 
class="cmbx-10">s[0] is a </span><br 
class="newline" /><span 
class="cmbx-10">s[1] is b </span><br 
class="newline" /><span 
class="cmbx-10">s[2] is c </span><br 
class="newline" /><span 
class="cmbx-10">s[3] is 0 </span><br 
class="newline" />
<!--l. 271--><p class="noindent" >Looks good.
<!--l. 273--><p class="noindent" >Here is the better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/better.c" > better.c&#x00A0;</a>
<!--l. 277--><p class="noindent" >But what if we get an empty line and the first characters is an EOF? It breaks. Another pesky bug in our
code. More specifically, we do not cater for an unexpected action, well at least in terms of the person that
coded the loop. Someone hitting control D (EOF) would be a likely occurrences, well a probabilistic
occurrence.
<!--l. 279--><p class="noindent" >OK. Let&#347; fix this boundary bug.
<div 
class="colorbox" id="colorbox7"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 300--><p class="noindent" >That works! Nice piece of code now. Looks like we are done.
<!--l. 302--><p class="noindent" >Here is the even better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/evenbetter.c" > evenbetter.c&#x00A0;</a>
<!--l. 306--><p class="noindent" >We have removed and tested all the edge cases. The code handles all the edge cases nicely
now.
<!--l. 308--><p class="noindent" >// - where the first character is newline
<!--l. 310--><p class="noindent" >// - where the first character is EOF
<!--l. 312--><p class="noindent" >// - where there is one character
<!--l. 314--><p class="noindent" >// - where there are more characters input than the max size of the array
<!--l. 316--><p class="noindent" >// - where characters are entered terminated by a newline
<!--l. 318--><p class="noindent" >// - where there are characters entered terminated by a EOF (control D)
<!--l. 322--><p class="noindent" >Em...are we sure. There are other boundary problems that could lurk here. What happens if the array is
nearly full - does it work? What happens if the array is exactly full? Or over full - what happens if any of
these conditions occur followed by a newline. Are these boundary conditions catered for? We will leave you
to determine the answer to that question.
                                                                                  
                                                                                  
<!--l. 324--><p class="noindent" ><span 
class="cmbx-10">You get the idea. Bugs lurk at boundaries. Conversely, if code works at boundaries it is</span>
<span 
class="cmbx-10">likely to work elsewhere</span>
<!--l. 326--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-11000"></a>TIP: Test pre and post conditions</h3>
<!--l. 328--><p class="noindent" >It is always a good idea to test for pre and post conditions - that is before and after, respectively, some
program executes. For example, we have already used defensive program to check input values are with in
range - an example of pre-condition testing. Let&#347; look at another simple example out of [KP, 1999] that
computes the average of n elements in an array a[]. Closer inspection of the code reveals that there is a
problem is n is less than or equal to 0.
<div 
class="colorbox" id="colorbox8"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /></div></div>
<!--l. 355--><p class="noindent" >A natural question is what to do if someone calls avg() with n=0? An array of zero elements does not
make much sense but an average of 0 does. Should our code catch the division by zero? with an assert, or
abort, or complain or be silent? One reasonable approach is to just return 0 as the average if n is less than
or equal to zero. While the code is idiomatic in style we need to tweak it to test pre-condition, as shown
below - note: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n</span></span></span>
<div 
class="colorbox" id="colorbox9"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 384--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-12000"></a>TIP: Use asserts or in the case of TinySearch MY_ASSERT()</h3>
<!--l. 386--><p class="noindent" >We have used MY_ASSERT() macros in the development of TinySearch and in the unit testing code with
SHOULD_BE(); for example:
<div 
class="colorbox" id="colorbox10"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;dictionary_test.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DICTIONARY*</span><span 
class="cmtt-10">&#x00A0;dict</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;InitDictionary();</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d1;</span><span 
class="cmtt-10">&#x00A0;d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d2;</span><span 
class="cmtt-10">&#x00A0;d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;2;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d1,</span><span 
class="cmtt-10">&#x00A0;"1");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d2,</span><span 
class="cmtt-10">&#x00A0;"2");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;end</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]-&#x003E;next);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;start</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d2);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;next</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;crawler.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;current_depth,</span><span 
class="cmtt-10">&#x00A0;max_depth;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;URLToBeVisited;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char**</span><span 
class="cmtt-10">&#x00A0;URLsLists;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;page;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;current_depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 425--><p class="noindent" >C provides an assertion facility in assert.h useful for pre and post condition testing. Asserts are
usually used for unexpected failure where there is no clean way to recover the logic control. For
example our avg() function could include a different solution then n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;</span></span></span>= 0 using the assert
function:
<div 
class="colorbox" id="colorbox11"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sume</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;assert(n</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;0);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 456--><p class="noindent" >If the assertion is in fact violated it will cause an abort and standard message to be printed
out:
<!--l. 458--><p class="noindent" >Assertion failed: n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003E;</span></span></span> 0, file avgtest.c, line 7 <br 
class="newline" />Abort(crash)<br 
class="newline" />
                                                                                  
                                                                                  
<!--l. 461--><p class="noindent" >Assertions are very useful in validating the expected properties of an interface or range of input
arguments.
<!--l. 464--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-13000"></a>TIP: Test for the unexpected: aka defensive programming</h3>
<!--l. 466--><p class="noindent" >Your crawler and indexer uses defensive programming for checking that the input arguments are logically
correct: e.g., that a path actually existed. But a useful technique when coding is to &#8220;expect the
unexpected&#8221; or code for the unexpected. Adding checks for n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x00A0;&#x003C;</span></span></span> 0 in avg() is an example. Another is
below:
<div 
class="colorbox" id="colorbox12"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;100}</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*can&#8217;t</span><span 
class="cmtt-10">&#x00A0;happen,</span><span 
class="cmtt-10">&#x00A0;well</span><span 
class="cmtt-10">&#x00A0;possibly,</span><span 
class="cmtt-10">&#x00A0;at</span><span 
class="cmtt-10">&#x00A0;Dartmouth</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;?&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;90)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;A&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><br /></div></div>
<!--l. 488--><p class="noindent" >The CS50 automatic grading program - a snippet is shown above ;-) handles negative grades (I<img 
src="artoftesting0x.png" alt="v  "  class="acute" >e yet to
do that) and very large grades. If the unexpected happens the code returns a ? This is a good example of
defensive programming. In essence our programmer is coding against incorrect use or illegal data. Other
examples include:
<!--l. 493--><p class="noindent" >1) Out of range subscripts <br 
class="newline" />2) NULL pointers <br 
class="newline" />3) Divide by zero <br 
class="newline" />
<!--l. 498--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-14000"></a>TIP: Always check error returns from functions</h3>
<!--l. 500--><p class="noindent" >A really good programmer will always check the return status from functions, system calls, and libraries. If
you neglect to look at the return status then how do you know that the function really worked. If your
code assumes it did not fail but it did then the segfault or error will be hard to debug. Better to always
check the error status returned by functions.
<!--l. 506--><p class="noindent" >Another example from [KP, 1996].
<div 
class="colorbox" id="colorbox13"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fp</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;fopen(outfile,</span><span 
class="cmtt-10">&#x00A0;&#8216;&#8216;w&#8217;&#8217;);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(some</span><span 
class="cmtt-10">&#x00A0;expression)</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;write</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;file*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fprintf(fp,</span><span 
class="cmtt-10">&#x00A0;...);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(fclose(fp)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><span 
class="cmtt-10">&#x00A0;{</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;check</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;errors</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;some</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;error</span><span 
class="cmtt-10">&#x00A0;occurred</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 527--><p class="noindent" >Output errors can be serious problem and if the file being written above fails and the error status not
checked on fprintf then the file data can be lost. But the check above will save you from removing the old
file if the new one was not written probably.
                                                                                  
                                                                                  
<!--l. 531--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-15000"></a>TIP: Others useful things to do</h3>
<!--l. 533--><p class="noindent" >1) Test incrementally and build confidence in your code. <br 
class="newline" />2) Write unit tests that can be re-run once fixes or changes have been made. <br 
class="newline" />3) Write self-contained unit tests <br 
class="newline" />3.1) Test inputs and outputs.<br 
class="newline" />3.2) Test the dataflow through the program. <br 
class="newline" />3.3) Test all the execution paths through the program. <br 
class="newline" />3.4) Question: what environment do you need to set up to do 3.1-3.3<br 
class="newline" />4) Stress test the code; start simple and advance (test crawler at depth 1 .. 10 for example).<br 
class="newline" />5) Don&#8217;t implement new features if there are known bugs in the system.<br 
class="newline" />6) Test for portability: run code and tests on multiple machines/OSs.<br 
class="newline" />7) Before shipping code make sure that the test code ifdefs are off.<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="cmbx-10">If you follow at least 50% of the tips in these notes you will write better code and it will</span>
<span 
class="cmbx-10">have considerably less bugs than if you did not apply these simple tips and strategy. Or your</span>
<span 
class="cmbx-10">money back.</span>
 
</body></html> 

                                                                                  


http://www.cs.dartmouth.edu/~campbell/cs50/artoftesting.html
Depth: 2
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="artoftesting.tex"> 
<meta name="date" content="2014-02-11 22:45:00"> 
<link rel="stylesheet" type="text/css" href="artoftesting.css"> 
</head><body 
>
<h1 class="likepartHead"><a 
 id="x1-1000"></a>CS 50 Software Design and Implementation</h1>
<h1 class="likepartHead"><a 
 id="x1-2000"></a>Lecture 17</h1>
<h1 class="likepartHead"><a 
 id="x1-3000"></a>The Art of Testing (and Writing Good Code)</h1>
<!--l. 21--><p class="noindent" >Edsger Dijkstra once said that testing can demonstrate the presence of bugs but not their absence. That is
good to keep in mind when you are developing code - good code. What is the difference between
debugging and testing? You debug when you know or have identified problems in your code. Testing is the
art of systematically trying to break code, which you think is bug free. In this lecture, we will deal with
the detective work needed to break code and try and uncover inconsistencies and problems with your
working code.
<!--l. 23--><p class="noindent" >In the next lecture, we will discuss how to automate unit testing - an extremely important part of the
design and development process. In these notes, we discuss neat strategies <span 
class="cmbx-10">such as test as you</span>
<span 
class="cmbx-10">code</span>; for example, many bugs exist at what we call <span 
class="cmbx-10">boundaries</span>: e.g., a program that reads
data up to the end of an allocated buffer; a program expecting a stream of characters gets a
newline or EOF character as the first character it reads; a for loop not written as a <span 
class="cmbx-10">C idiom</span>
attempts to write one memory location beyond the end of an array (C can be dangerous, for
example, it has no subscript checking). If you think about common bugs that could creep
into code while writing code then that could save you significant time in the development
process.
<!--l. 27--><p class="noindent" >The material used in the lecture is strongly influenced by: <span 
class="cmbx-10">[KP, 1999] </span>The Practice of Programming
(Addison-Wesley Professional Computing Series) by Brian W. Kernighan, Rob Pike. The notes use a
number of programming examples from Chapter 6 on Testing. The text also reflects and cites material
from that chapter. This is an outstanding book and strongly recommended to advance your knowledge on
good programming practices. We use some coded examples from [KP, 1999] as cited in the
notes.
<!--l. 29--><p class="noindent" >Another short reference I like is <a 
href="http://www.ibm.com/developerworks/library/j-test.html" >Jeff Canna&#8217;s &#8220;Testing, Fun, Really&#8221;</a>. I would recommend that you read
Chapter 6 from [KP, 1999] and Jeff Canna article.
<!--l. 31--><p class="noindent" >BTW, you can skip these notes if you write bug free code ;-)
<h3 class="likesectionHead"><a 
 id="x1-4000"></a>Goals</h3>
<!--l. 35--><p class="noindent" >We plan to learn the following from today&#8217;s lecture:
                                                                                  
                                                                                  
     <ul class="itemize1">
     <li class="itemize">I write bug free code - testing is a waste of time?
     </li>
     <li class="itemize">TIP: Test as you write code
     </li>
     <li class="itemize">TIP: Use C idioms and be consistent when you write code
     </li>
     <li class="itemize">TIP: Test code at its boundaries
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only newline <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#8217;\n&#8217;</span></span></span> character
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only EOF character
     </li>
     <li class="itemize">TIP: Use asserts or in the case of TinySearch MY_ASSERT()
     </li>
     <li class="itemize">TIP: Test pre and post conditions
     </li>
     <li class="itemize">TIP: Test for the unexpected: aka defensive programming
     </li>
     <li class="itemize">TIP: Always check error returns from functions
     </li>
     <li class="itemize">TIP: Others useful things to do</li></ul>
<!--l. 51--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-5000"></a>I write bug free code - testing is a waste of time?</h3>
<!--l. 53--><p class="noindent" >Many people have the attitude that testing code is a waste of time and boring - why do it? When one
considers the software lifecycle discussed in class: procurement, requirements, design, coding, testing,
debugging, integration and bake off then I would say that testing and debugging take the largest chuck of
time. It is smart to develop tools and code to automate the testing of code. Why do this? Well the simple
answer is it saves time and pushes the sometimes tedious task of testing into tools and away from humans.
Imagine you design and develop a complex system and sell it to a customer who subsequently finds a
serious bug out in the wild; that is to say, when the product is deployed in a power station, across a
country such as an air traffic control system, in washing machines, or an app. The point is that you
fix the problem but how do you know you haven&#8217;t broken something else while fixing your
serious bug? You don&#8217;t know unless you have developed a set of tools to systematic retest
the code. If you have developed a set of integration tests, sub-system tests and unit tests
then you can quickly rerun them before you reship the new product with the bug fix. If all
                                                                                  
                                                                                  
the tests pass then you have some confidence that the change you made did not introduce
additional problems. Note, I use the phase &#8220;some confidence&#8221; because you are never 100%
sure.
<!--l. 55--><p class="noindent" >Let me restate the difference between debugging and testing again - with some philosophical comments. It
is good to have that clear in your mind:
<!--l. 57--><p class="noindent" ><span 
class="cmbx-10">Testing </span>is a determined, systematic attempt to break a program that you think is working. As discussed
above, putting smarts into the development of a set of tools and test harness can automate this process.
Story: this lecturer started his software career working for a company called Plessey Radar in
the UK. His first assignment was testing someone else code. Fortunately, this was very cool
because the code under test was the kernel of an Operating System. I did applied math at
university and knew nothing about software. It might have felt like grunt work to a newbie
on the job but I learnt how to design an operating system from the ground up. Later in my
career I worked for company that brought in a consultant to run integration tests again code -
my code. I was not happy dealing with testers until they found bugs in my code that was
already under beta release. After that I had time and respect for them. Today, I still think
producing smart testing tools to automate the testing of your code produces much more robust
code.
<!--l. 59--><p class="noindent" ><span 
class="cmbx-10">Debugging </span>is what you do when you know that the program is broken (e.g., segfault), fails (e.g.,
DDNODE is never linked into the hash table), underperforms (e.g., the memory leaks bring
the system to a slow but grinding halt) or acts inconsistently (e.g., never terminates when it
should). These are all bugs that testing can find. Better to find them and fix them. Sometimes
bugs cascade, i.e., one bug creates others and so on. These types of bugs are hard to fix. In
essence, the &#8220;bug chain&#8221; needs to be worked through to get to the real culprit at the start of
the chain. Many times it is not obvious what problems in a system are linked and therefore
requires some detective work: in the last lecture we <span 
class="cmbx-10">forced the bug out into the open</span>
before swatting that pesky bug - which, you recall, lurked at the boundary of the for loop
logic.
<!--l. 61--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-6000"></a>TIP: Test as you write code</h3>
<!--l. 63--><p class="noindent" >The earlier you find a problem with your code the better; it will save significant time and your company
money. You will also get respect from other programmers. Digging bugs out months after you have written
and forgotten the code is a serious challenge: test as you go. I know that for most labs you have sat a the
terminal and just hacked at the code to reveal and fix bugs - you sit there praying, hacking some
printfs and hit make and them run your code: you are doing this 100s of times. It is not a
smart to work like this and represents a dumb brute force method - you&#8217;ll get no respect in
industry for that. So be smart add a couple of new skills to your cs50 toolbox: &#8220;test as you go is
one&#8221;. Using C idioms is another great way to limit bugs; for example, if you do not blindly
hack code but enter code and sit back for a moment and read that while or for loop logic
through carefully then you have already tested your code on one level before you have hit
the gcc button. Doesn&#8217;t this make good sense? Yes, it does make good sense and having put
                                                                                  
                                                                                  
your code through inspection before you compile it is great, really great, and it comes for
free.
<!--l. 65--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-7000"></a>TIP: Use C idioms and be consistent when you write code</h3>
<!--l. 67--><p class="noindent" >You already know many C idioms even if we haven&#8217;t always labeled them that way. But there are many
ways to write a simple loop for example:
<div 
class="colorbox" id="colorbox1"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;first</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;&#x003C;=</span><span 
class="cmtt-10">&#x00A0;n-1)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;next</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;final</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;--i</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div></div>
<!--l. 97--><p class="noindent" >There are many ways to skin a cat - that is horrible saying, right and my cat Tiger would be alarmed. The
simple loop is developed in three different ways. But like the English language the C programming
language has idioms: where idiom means: <span 
class="cmbx-10">C idioms are conventional ways that experienced</span>
<span 
class="cmbx-10">programmers write common pieces of code. A central part of any language is developing</span>
<span 
class="cmbx-10">familiarity with its idioms </span>[KP, 1999].
<!--l. 102--><p class="noindent" >While all of the loops shown above would work they are not C idioms. The C idiom is:
<div 
class="colorbox" id="colorbox2"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Idiomatic</span><span 
class="cmtt-10">&#x00A0;form</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div>                 </div>
<!--l. 118--><p class="noindent" >Being consistent when programming C will help enormously. For example, if you are use to writing
idiomatic code then when you see a piece of code that is not idiomatic you should stop and take a close
look at that code: maybe a boundary problem is more likely? If code is written the same way each time
then when you see code that is not idiomatic it either suggests poor code or some genuine difference exists
that the idiom does not cover. Either way: take a second close look to convince yourself its one or the
other.
<!--l. 121--><p class="noindent" >Here are some more examples of C idioms that you should be familiar with:
<div 
class="colorbox" id="colorbox3"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Infinite</span><span 
class="cmtt-10">&#x00A0;loop</span><span 
class="cmtt-10">&#x00A0;idioms</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(;;)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;or</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(1)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;string</span><span 
class="cmtt-10">&#x00A0;copy</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;p</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(strlen(buf)+1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(p);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;strcpy(p,</span><span 
class="cmtt-10">&#x00A0;buf);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;reading</span><span 
class="cmtt-10">&#x00A0;in</span><span 
class="cmtt-10">&#x00A0;and</span><span 
class="cmtt-10">&#x00A0;writing</span><span 
class="cmtt-10">&#x00A0;out</span><span 
class="cmtt-10">&#x00A0;characters</span><span 
class="cmtt-10">&#x00A0;until</span><span 
class="cmtt-10">&#x00A0;EOF</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;((c</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;putchar(c);</span><br /><br /></div></div>
<!--l. 160--><p class="noindent" >Here are some TinySearch idioms that you should be using in your code. See solution for lab4 for many
examples.
<div 
class="colorbox" id="colorbox4"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK,</span><span 
class="cmtt-10">&#x00A0;BZERO</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;URLNODE*</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(URLNODE));</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(n);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;d;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;visited</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;BZERO(n-&#x003E;url,</span><span 
class="cmtt-10">&#x00A0;MAX_URL_LENGTH);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;LOG</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(page</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;LOG("CANNOT</span><span 
class="cmtt-10">&#x00A0;crawl</span><span 
class="cmtt-10">&#x00A0;seed</span><span 
class="cmtt-10">&#x00A0;page.</span><span 
class="cmtt-10">&#x00A0;Panic!");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;exit(-1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;ASSERT</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 191--><p class="noindent" >So write in idioms as much as possible; it limits bugs at boundaries.
<!--l. 193--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-8000"></a>TIP: Test code at its boundaries</h3>
<!--l. 195--><p class="noindent" >In what follows, we use a series of code snippets from [KP, 1999] to illustrate how to code to remove
boundary bugs. It is a simple yet elegant example of writing code to handle all the boundary conditions
that may present themselves.
                                                                                  
                                                                                  
<!--l. 197--><p class="noindent" >Boundary testing assumes you test a small snippet of code at a time - sort of micro testing of code
sequences or what should be idiomatic code. The example code does not use idioms and is poorly written
to cater for boundary bugs. It is set up to illustrate that. But we have all written poor code like this. The
take home from this section is how the code evolves once we think about where the boundary bugs
are. So, for example, as you write a loop of some sort check there and then that condition
branches the right way or that execution would go through the loop the correct number of
times.
<!--l. 199--><p class="noindent" >The technique is called <span 
class="cmbx-10">boundary condition testing </span>because you probe at the natural boundaries of the
program, its data and its data structures (if they exist). For example, for the code below we probe for the
following boundaries:
<!--l. 201--><p class="noindent" >1) empty input <br 
class="newline" />2) a single input character <br 
class="newline" />3) an exactly full array - but could be malloced buffer <br 
class="newline" />
<!--l. 205--><p class="noindent" >and so on. It could have been
<!--l. 207--><p class="noindent" >4) empty queue <br 
class="newline" />5) no collisions in a hash table <br 
class="newline" />6) collisions in a hash table <br 
class="newline" />7) add to the end of a cluster, etc.<br 
class="newline" />
<!--l. 212--><p class="noindent" >Consider the following code snippet from [KP, 1999]:
<!--l. 214--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-9000"></a>BOUNDARY TEST: Empty Input with only newline character</h3>
<div 
class="colorbox" id="colorbox5"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;(s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;&amp;&amp;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;++i)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;;</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;do</span><span 
class="cmtt-10">&#x00A0;nothing</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[--i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 234--><p class="noindent" >Looking at this code the first thing that should strike us is that it&#347; not a C idiom. That should make us
look very closely at the loop logic; particularly, the loops conditional logic. Maybe, after studying the code
thinking about characters being input we convince ourselves that the code is non idiomatic but works.
Now start to test boundaries. Consider 1) above where there is no input but a newline - the user simply
types carriage return for example. The resulting code would terminate immediately on the
first iteration with i set to zero. The last line that should replace a newline character with
a end of string character writes NULL to s[i-1], which is before the start of the array. Not
a good idea hey. Thinking about a boundary test gets the pesky bug out into the open to
swat.
<!--l. 236--><p class="noindent" >Here is the nasty edge case code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/edgecases.c" > edgecases.c&#x00A0;</a>
                                                                                  
                                                                                  
<!--l. 241--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-10000"></a>BOUNDARY TEST: Empty Input with only EOF character</h3>
<!--l. 243--><p class="noindent" >OK. The smart thing to do is rewrite this convoluted loop as an idiom and solve the problem; for
example:
<div 
class="colorbox" id="colorbox6"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;note</span><span 
class="cmtt-10">&#x00A0;we</span><span 
class="cmtt-10">&#x00A0;switch</span><span 
class="cmtt-10">&#x00A0;++i</span><span 
class="cmtt-10">&#x00A0;=&#x003E;</span><span 
class="cmtt-10">&#x00A0;i++,</span><span 
class="cmtt-10">&#x00A0;the</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 264--><p class="noindent" >Inspecting the code above we can easily see that the previous boundary problem is solved with the
new idiomatic code. It handles the case when the input is solely a newline beautifully. If we
mentally compute through reading 1, 2 or 3 characters we see it also works; for example a b c <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\n</span></span></span>
works.
<!--l. 266--><p class="noindent" ><span 
class="cmbx-10">s[0] is a </span><br 
class="newline" /><span 
class="cmbx-10">s[1] is b </span><br 
class="newline" /><span 
class="cmbx-10">s[2] is c </span><br 
class="newline" /><span 
class="cmbx-10">s[3] is 0 </span><br 
class="newline" />
<!--l. 271--><p class="noindent" >Looks good.
<!--l. 273--><p class="noindent" >Here is the better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/better.c" > better.c&#x00A0;</a>
<!--l. 277--><p class="noindent" >But what if we get an empty line and the first characters is an EOF? It breaks. Another pesky bug in our
code. More specifically, we do not cater for an unexpected action, well at least in terms of the person that
coded the loop. Someone hitting control D (EOF) would be a likely occurrences, well a probabilistic
occurrence.
<!--l. 279--><p class="noindent" >OK. Let&#347; fix this boundary bug.
<div 
class="colorbox" id="colorbox7"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 300--><p class="noindent" >That works! Nice piece of code now. Looks like we are done.
<!--l. 302--><p class="noindent" >Here is the even better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/evenbetter.c" > evenbetter.c&#x00A0;</a>
<!--l. 306--><p class="noindent" >We have removed and tested all the edge cases. The code handles all the edge cases nicely
now.
<!--l. 308--><p class="noindent" >// - where the first character is newline
<!--l. 310--><p class="noindent" >// - where the first character is EOF
<!--l. 312--><p class="noindent" >// - where there is one character
<!--l. 314--><p class="noindent" >// - where there are more characters input than the max size of the array
<!--l. 316--><p class="noindent" >// - where characters are entered terminated by a newline
<!--l. 318--><p class="noindent" >// - where there are characters entered terminated by a EOF (control D)
<!--l. 322--><p class="noindent" >Em...are we sure. There are other boundary problems that could lurk here. What happens if the array is
nearly full - does it work? What happens if the array is exactly full? Or over full - what happens if any of
these conditions occur followed by a newline. Are these boundary conditions catered for? We will leave you
to determine the answer to that question.
                                                                                  
                                                                                  
<!--l. 324--><p class="noindent" ><span 
class="cmbx-10">You get the idea. Bugs lurk at boundaries. Conversely, if code works at boundaries it is</span>
<span 
class="cmbx-10">likely to work elsewhere</span>
<!--l. 326--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-11000"></a>TIP: Test pre and post conditions</h3>
<!--l. 328--><p class="noindent" >It is always a good idea to test for pre and post conditions - that is before and after, respectively, some
program executes. For example, we have already used defensive program to check input values are with in
range - an example of pre-condition testing. Let&#347; look at another simple example out of [KP, 1999] that
computes the average of n elements in an array a[]. Closer inspection of the code reveals that there is a
problem is n is less than or equal to 0.
<div 
class="colorbox" id="colorbox8"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /></div></div>
<!--l. 355--><p class="noindent" >A natural question is what to do if someone calls avg() with n=0? An array of zero elements does not
make much sense but an average of 0 does. Should our code catch the division by zero? with an assert, or
abort, or complain or be silent? One reasonable approach is to just return 0 as the average if n is less than
or equal to zero. While the code is idiomatic in style we need to tweak it to test pre-condition, as shown
below - note: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n</span></span></span>
<div 
class="colorbox" id="colorbox9"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 384--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-12000"></a>TIP: Use asserts or in the case of TinySearch MY_ASSERT()</h3>
<!--l. 386--><p class="noindent" >We have used MY_ASSERT() macros in the development of TinySearch and in the unit testing code with
SHOULD_BE(); for example:
<div 
class="colorbox" id="colorbox10"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;dictionary_test.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DICTIONARY*</span><span 
class="cmtt-10">&#x00A0;dict</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;InitDictionary();</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d1;</span><span 
class="cmtt-10">&#x00A0;d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d2;</span><span 
class="cmtt-10">&#x00A0;d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;2;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d1,</span><span 
class="cmtt-10">&#x00A0;"1");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d2,</span><span 
class="cmtt-10">&#x00A0;"2");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;end</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]-&#x003E;next);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;start</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d2);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;next</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;crawler.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;current_depth,</span><span 
class="cmtt-10">&#x00A0;max_depth;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;URLToBeVisited;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char**</span><span 
class="cmtt-10">&#x00A0;URLsLists;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;page;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;current_depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 425--><p class="noindent" >C provides an assertion facility in assert.h useful for pre and post condition testing. Asserts are
usually used for unexpected failure where there is no clean way to recover the logic control. For
example our avg() function could include a different solution then n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;</span></span></span>= 0 using the assert
function:
<div 
class="colorbox" id="colorbox11"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sume</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;assert(n</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;0);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 456--><p class="noindent" >If the assertion is in fact violated it will cause an abort and standard message to be printed
out:
<!--l. 458--><p class="noindent" >Assertion failed: n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003E;</span></span></span> 0, file avgtest.c, line 7 <br 
class="newline" />Abort(crash)<br 
class="newline" />
                                                                                  
                                                                                  
<!--l. 461--><p class="noindent" >Assertions are very useful in validating the expected properties of an interface or range of input
arguments.
<!--l. 464--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-13000"></a>TIP: Test for the unexpected: aka defensive programming</h3>
<!--l. 466--><p class="noindent" >Your crawler and indexer uses defensive programming for checking that the input arguments are logically
correct: e.g., that a path actually existed. But a useful technique when coding is to &#8220;expect the
unexpected&#8221; or code for the unexpected. Adding checks for n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x00A0;&#x003C;</span></span></span> 0 in avg() is an example. Another is
below:
<div 
class="colorbox" id="colorbox12"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;100}</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*can&#8217;t</span><span 
class="cmtt-10">&#x00A0;happen,</span><span 
class="cmtt-10">&#x00A0;well</span><span 
class="cmtt-10">&#x00A0;possibly,</span><span 
class="cmtt-10">&#x00A0;at</span><span 
class="cmtt-10">&#x00A0;Dartmouth</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;?&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;90)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;A&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><br /></div></div>
<!--l. 488--><p class="noindent" >The CS50 automatic grading program - a snippet is shown above ;-) handles negative grades (I<img 
src="artoftesting0x.png" alt="v  "  class="acute" >e yet to
do that) and very large grades. If the unexpected happens the code returns a ? This is a good example of
defensive programming. In essence our programmer is coding against incorrect use or illegal data. Other
examples include:
<!--l. 493--><p class="noindent" >1) Out of range subscripts <br 
class="newline" />2) NULL pointers <br 
class="newline" />3) Divide by zero <br 
class="newline" />
<!--l. 498--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-14000"></a>TIP: Always check error returns from functions</h3>
<!--l. 500--><p class="noindent" >A really good programmer will always check the return status from functions, system calls, and libraries. If
you neglect to look at the return status then how do you know that the function really worked. If your
code assumes it did not fail but it did then the segfault or error will be hard to debug. Better to always
check the error status returned by functions.
<!--l. 506--><p class="noindent" >Another example from [KP, 1996].
<div 
class="colorbox" id="colorbox13"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fp</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;fopen(outfile,</span><span 
class="cmtt-10">&#x00A0;&#8216;&#8216;w&#8217;&#8217;);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(some</span><span 
class="cmtt-10">&#x00A0;expression)</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;write</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;file*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fprintf(fp,</span><span 
class="cmtt-10">&#x00A0;...);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(fclose(fp)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><span 
class="cmtt-10">&#x00A0;{</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;check</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;errors</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;some</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;error</span><span 
class="cmtt-10">&#x00A0;occurred</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 527--><p class="noindent" >Output errors can be serious problem and if the file being written above fails and the error status not
checked on fprintf then the file data can be lost. But the check above will save you from removing the old
file if the new one was not written probably.
                                                                                  
                                                                                  
<!--l. 531--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-15000"></a>TIP: Others useful things to do</h3>
<!--l. 533--><p class="noindent" >1) Test incrementally and build confidence in your code. <br 
class="newline" />2) Write unit tests that can be re-run once fixes or changes have been made. <br 
class="newline" />3) Write self-contained unit tests <br 
class="newline" />3.1) Test inputs and outputs.<br 
class="newline" />3.2) Test the dataflow through the program. <br 
class="newline" />3.3) Test all the execution paths through the program. <br 
class="newline" />3.4) Question: what environment do you need to set up to do 3.1-3.3<br 
class="newline" />4) Stress test the code; start simple and advance (test crawler at depth 1 .. 10 for example).<br 
class="newline" />5) Don&#8217;t implement new features if there are known bugs in the system.<br 
class="newline" />6) Test for portability: run code and tests on multiple machines/OSs.<br 
class="newline" />7) Before shipping code make sure that the test code ifdefs are off.<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="cmbx-10">If you follow at least 50% of the tips in these notes you will write better code and it will</span>
<span 
class="cmbx-10">have considerably less bugs than if you did not apply these simple tips and strategy. Or your</span>
<span 
class="cmbx-10">money back.</span>
 
</body></html> 

                                                                                  


http://www.cs.dartmouth.edu/~campbell/cs50/artoftesting.html
Depth: 2
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"  
  "http://www.w3.org/TR/html4/loose.dtd">  
<html > 
<head><title></title> 
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<meta name="originator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)"> 
<!-- html --> 
<meta name="src" content="artoftesting.tex"> 
<meta name="date" content="2014-02-11 22:45:00"> 
<link rel="stylesheet" type="text/css" href="artoftesting.css"> 
</head><body 
>
<h1 class="likepartHead"><a 
 id="x1-1000"></a>CS 50 Software Design and Implementation</h1>
<h1 class="likepartHead"><a 
 id="x1-2000"></a>Lecture 17</h1>
<h1 class="likepartHead"><a 
 id="x1-3000"></a>The Art of Testing (and Writing Good Code)</h1>
<!--l. 21--><p class="noindent" >Edsger Dijkstra once said that testing can demonstrate the presence of bugs but not their absence. That is
good to keep in mind when you are developing code - good code. What is the difference between
debugging and testing? You debug when you know or have identified problems in your code. Testing is the
art of systematically trying to break code, which you think is bug free. In this lecture, we will deal with
the detective work needed to break code and try and uncover inconsistencies and problems with your
working code.
<!--l. 23--><p class="noindent" >In the next lecture, we will discuss how to automate unit testing - an extremely important part of the
design and development process. In these notes, we discuss neat strategies <span 
class="cmbx-10">such as test as you</span>
<span 
class="cmbx-10">code</span>; for example, many bugs exist at what we call <span 
class="cmbx-10">boundaries</span>: e.g., a program that reads
data up to the end of an allocated buffer; a program expecting a stream of characters gets a
newline or EOF character as the first character it reads; a for loop not written as a <span 
class="cmbx-10">C idiom</span>
attempts to write one memory location beyond the end of an array (C can be dangerous, for
example, it has no subscript checking). If you think about common bugs that could creep
into code while writing code then that could save you significant time in the development
process.
<!--l. 27--><p class="noindent" >The material used in the lecture is strongly influenced by: <span 
class="cmbx-10">[KP, 1999] </span>The Practice of Programming
(Addison-Wesley Professional Computing Series) by Brian W. Kernighan, Rob Pike. The notes use a
number of programming examples from Chapter 6 on Testing. The text also reflects and cites material
from that chapter. This is an outstanding book and strongly recommended to advance your knowledge on
good programming practices. We use some coded examples from [KP, 1999] as cited in the
notes.
<!--l. 29--><p class="noindent" >Another short reference I like is <a 
href="http://www.ibm.com/developerworks/library/j-test.html" >Jeff Canna&#8217;s &#8220;Testing, Fun, Really&#8221;</a>. I would recommend that you read
Chapter 6 from [KP, 1999] and Jeff Canna article.
<!--l. 31--><p class="noindent" >BTW, you can skip these notes if you write bug free code ;-)
<h3 class="likesectionHead"><a 
 id="x1-4000"></a>Goals</h3>
<!--l. 35--><p class="noindent" >We plan to learn the following from today&#8217;s lecture:
                                                                                  
                                                                                  
     <ul class="itemize1">
     <li class="itemize">I write bug free code - testing is a waste of time?
     </li>
     <li class="itemize">TIP: Test as you write code
     </li>
     <li class="itemize">TIP: Use C idioms and be consistent when you write code
     </li>
     <li class="itemize">TIP: Test code at its boundaries
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only newline <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#8217;\n&#8217;</span></span></span> character
     </li>
     <li class="itemize">BOUNDARY TEST: Empty Input with only EOF character
     </li>
     <li class="itemize">TIP: Use asserts or in the case of TinySearch MY_ASSERT()
     </li>
     <li class="itemize">TIP: Test pre and post conditions
     </li>
     <li class="itemize">TIP: Test for the unexpected: aka defensive programming
     </li>
     <li class="itemize">TIP: Always check error returns from functions
     </li>
     <li class="itemize">TIP: Others useful things to do</li></ul>
<!--l. 51--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-5000"></a>I write bug free code - testing is a waste of time?</h3>
<!--l. 53--><p class="noindent" >Many people have the attitude that testing code is a waste of time and boring - why do it? When one
considers the software lifecycle discussed in class: procurement, requirements, design, coding, testing,
debugging, integration and bake off then I would say that testing and debugging take the largest chuck of
time. It is smart to develop tools and code to automate the testing of code. Why do this? Well the simple
answer is it saves time and pushes the sometimes tedious task of testing into tools and away from humans.
Imagine you design and develop a complex system and sell it to a customer who subsequently finds a
serious bug out in the wild; that is to say, when the product is deployed in a power station, across a
country such as an air traffic control system, in washing machines, or an app. The point is that you
fix the problem but how do you know you haven&#8217;t broken something else while fixing your
serious bug? You don&#8217;t know unless you have developed a set of tools to systematic retest
the code. If you have developed a set of integration tests, sub-system tests and unit tests
then you can quickly rerun them before you reship the new product with the bug fix. If all
                                                                                  
                                                                                  
the tests pass then you have some confidence that the change you made did not introduce
additional problems. Note, I use the phase &#8220;some confidence&#8221; because you are never 100%
sure.
<!--l. 55--><p class="noindent" >Let me restate the difference between debugging and testing again - with some philosophical comments. It
is good to have that clear in your mind:
<!--l. 57--><p class="noindent" ><span 
class="cmbx-10">Testing </span>is a determined, systematic attempt to break a program that you think is working. As discussed
above, putting smarts into the development of a set of tools and test harness can automate this process.
Story: this lecturer started his software career working for a company called Plessey Radar in
the UK. His first assignment was testing someone else code. Fortunately, this was very cool
because the code under test was the kernel of an Operating System. I did applied math at
university and knew nothing about software. It might have felt like grunt work to a newbie
on the job but I learnt how to design an operating system from the ground up. Later in my
career I worked for company that brought in a consultant to run integration tests again code -
my code. I was not happy dealing with testers until they found bugs in my code that was
already under beta release. After that I had time and respect for them. Today, I still think
producing smart testing tools to automate the testing of your code produces much more robust
code.
<!--l. 59--><p class="noindent" ><span 
class="cmbx-10">Debugging </span>is what you do when you know that the program is broken (e.g., segfault), fails (e.g.,
DDNODE is never linked into the hash table), underperforms (e.g., the memory leaks bring
the system to a slow but grinding halt) or acts inconsistently (e.g., never terminates when it
should). These are all bugs that testing can find. Better to find them and fix them. Sometimes
bugs cascade, i.e., one bug creates others and so on. These types of bugs are hard to fix. In
essence, the &#8220;bug chain&#8221; needs to be worked through to get to the real culprit at the start of
the chain. Many times it is not obvious what problems in a system are linked and therefore
requires some detective work: in the last lecture we <span 
class="cmbx-10">forced the bug out into the open</span>
before swatting that pesky bug - which, you recall, lurked at the boundary of the for loop
logic.
<!--l. 61--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-6000"></a>TIP: Test as you write code</h3>
<!--l. 63--><p class="noindent" >The earlier you find a problem with your code the better; it will save significant time and your company
money. You will also get respect from other programmers. Digging bugs out months after you have written
and forgotten the code is a serious challenge: test as you go. I know that for most labs you have sat a the
terminal and just hacked at the code to reveal and fix bugs - you sit there praying, hacking some
printfs and hit make and them run your code: you are doing this 100s of times. It is not a
smart to work like this and represents a dumb brute force method - you&#8217;ll get no respect in
industry for that. So be smart add a couple of new skills to your cs50 toolbox: &#8220;test as you go is
one&#8221;. Using C idioms is another great way to limit bugs; for example, if you do not blindly
hack code but enter code and sit back for a moment and read that while or for loop logic
through carefully then you have already tested your code on one level before you have hit
the gcc button. Doesn&#8217;t this make good sense? Yes, it does make good sense and having put
                                                                                  
                                                                                  
your code through inspection before you compile it is great, really great, and it comes for
free.
<!--l. 65--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-7000"></a>TIP: Use C idioms and be consistent when you write code</h3>
<!--l. 67--><p class="noindent" >You already know many C idioms even if we haven&#8217;t always labeled them that way. But there are many
ways to write a simple loop for example:
<div 
class="colorbox" id="colorbox1"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;first</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;&#x003C;=</span><span 
class="cmtt-10">&#x00A0;n-1)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;next</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i++]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;final</span><span 
class="cmtt-10">&#x00A0;example</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;--i</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div></div>
<!--l. 97--><p class="noindent" >There are many ways to skin a cat - that is horrible saying, right and my cat Tiger would be alarmed. The
simple loop is developed in three different ways. But like the English language the C programming
language has idioms: where idiom means: <span 
class="cmbx-10">C idioms are conventional ways that experienced</span>
<span 
class="cmbx-10">programmers write common pieces of code. A central part of any language is developing</span>
<span 
class="cmbx-10">familiarity with its idioms </span>[KP, 1999].
<!--l. 102--><p class="noindent" >While all of the loops shown above would work they are not C idioms. The C idiom is:
<div 
class="colorbox" id="colorbox2"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Idiomatic</span><span 
class="cmtt-10">&#x00A0;form</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++</span><span 
class="cmtt-10">&#x00A0;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;array[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1.0;</span><br /><br /></div>                 </div>
<!--l. 118--><p class="noindent" >Being consistent when programming C will help enormously. For example, if you are use to writing
idiomatic code then when you see a piece of code that is not idiomatic you should stop and take a close
look at that code: maybe a boundary problem is more likely? If code is written the same way each time
then when you see code that is not idiomatic it either suggests poor code or some genuine difference exists
that the idiom does not cover. Either way: take a second close look to convince yourself its one or the
other.
<!--l. 121--><p class="noindent" >Here are some more examples of C idioms that you should be familiar with:
<div 
class="colorbox" id="colorbox3"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Infinite</span><span 
class="cmtt-10">&#x00A0;loop</span><span 
class="cmtt-10">&#x00A0;idioms</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(;;)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;or</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(1)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;string</span><span 
class="cmtt-10">&#x00A0;copy</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;p</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(strlen(buf)+1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(p);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;strcpy(p,</span><span 
class="cmtt-10">&#x00A0;buf);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;reading</span><span 
class="cmtt-10">&#x00A0;in</span><span 
class="cmtt-10">&#x00A0;and</span><span 
class="cmtt-10">&#x00A0;writing</span><span 
class="cmtt-10">&#x00A0;out</span><span 
class="cmtt-10">&#x00A0;characters</span><span 
class="cmtt-10">&#x00A0;until</span><span 
class="cmtt-10">&#x00A0;EOF</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;((c</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;putchar(c);</span><br /><br /></div></div>
<!--l. 160--><p class="noindent" >Here are some TinySearch idioms that you should be using in your code. See solution for lab4 for many
examples.
<div 
class="colorbox" id="colorbox4"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;malloc,</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK,</span><span 
class="cmtt-10">&#x00A0;BZERO</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;URLNODE*</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(URLNODE));</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MALLOC_CHECK(n);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;d;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;n-&#x003E;visited</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;BZERO(n-&#x003E;url,</span><span 
class="cmtt-10">&#x00A0;MAX_URL_LENGTH);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;LOG</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(page</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL)</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;LOG("CANNOT</span><span 
class="cmtt-10">&#x00A0;crawl</span><span 
class="cmtt-10">&#x00A0;seed</span><span 
class="cmtt-10">&#x00A0;page.</span><span 
class="cmtt-10">&#x00A0;Panic!");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;exit(-1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;ASSERT</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 191--><p class="noindent" >So write in idioms as much as possible; it limits bugs at boundaries.
<!--l. 193--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-8000"></a>TIP: Test code at its boundaries</h3>
<!--l. 195--><p class="noindent" >In what follows, we use a series of code snippets from [KP, 1999] to illustrate how to code to remove
boundary bugs. It is a simple yet elegant example of writing code to handle all the boundary conditions
that may present themselves.
                                                                                  
                                                                                  
<!--l. 197--><p class="noindent" >Boundary testing assumes you test a small snippet of code at a time - sort of micro testing of code
sequences or what should be idiomatic code. The example code does not use idioms and is poorly written
to cater for boundary bugs. It is set up to illustrate that. But we have all written poor code like this. The
take home from this section is how the code evolves once we think about where the boundary bugs
are. So, for example, as you write a loop of some sort check there and then that condition
branches the right way or that execution would go through the loop the correct number of
times.
<!--l. 199--><p class="noindent" >The technique is called <span 
class="cmbx-10">boundary condition testing </span>because you probe at the natural boundaries of the
program, its data and its data structures (if they exist). For example, for the code below we probe for the
following boundaries:
<!--l. 201--><p class="noindent" >1) empty input <br 
class="newline" />2) a single input character <br 
class="newline" />3) an exactly full array - but could be malloced buffer <br 
class="newline" />
<!--l. 205--><p class="noindent" >and so on. It could have been
<!--l. 207--><p class="noindent" >4) empty queue <br 
class="newline" />5) no collisions in a hash table <br 
class="newline" />6) collisions in a hash table <br 
class="newline" />7) add to the end of a cluster, etc.<br 
class="newline" />
<!--l. 212--><p class="noindent" >Consider the following code snippet from [KP, 1999]:
<!--l. 214--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-9000"></a>BOUNDARY TEST: Empty Input with only newline character</h3>
<div 
class="colorbox" id="colorbox5"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;(s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;!=</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;&amp;&amp;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;++i)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;;</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;do</span><span 
class="cmtt-10">&#x00A0;nothing</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[--i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 234--><p class="noindent" >Looking at this code the first thing that should strike us is that it&#347; not a C idiom. That should make us
look very closely at the loop logic; particularly, the loops conditional logic. Maybe, after studying the code
thinking about characters being input we convince ourselves that the code is non idiomatic but works.
Now start to test boundaries. Consider 1) above where there is no input but a newline - the user simply
types carriage return for example. The resulting code would terminate immediately on the
first iteration with i set to zero. The last line that should replace a newline character with
a end of string character writes NULL to s[i-1], which is before the start of the array. Not
a good idea hey. Thinking about a boundary test gets the pesky bug out into the open to
swat.
<!--l. 236--><p class="noindent" >Here is the nasty edge case code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/edgecases.c" > edgecases.c&#x00A0;</a>
                                                                                  
                                                                                  
<!--l. 241--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-10000"></a>BOUNDARY TEST: Empty Input with only EOF character</h3>
<!--l. 243--><p class="noindent" >OK. The smart thing to do is rewrite this convoluted loop as an idiom and solve the problem; for
example:
<div 
class="colorbox" id="colorbox6"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><span 
class="cmtt-10">&#x00A0;//</span><span 
class="cmtt-10">&#x00A0;note</span><span 
class="cmtt-10">&#x00A0;we</span><span 
class="cmtt-10">&#x00A0;switch</span><span 
class="cmtt-10">&#x00A0;++i</span><span 
class="cmtt-10">&#x00A0;=&#x003E;</span><span 
class="cmtt-10">&#x00A0;i++,</span><span 
class="cmtt-10">&#x00A0;the</span><span 
class="cmtt-10">&#x00A0;idiom</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 264--><p class="noindent" >Inspecting the code above we can easily see that the previous boundary problem is solved with the
new idiomatic code. It handles the case when the input is solely a newline beautifully. If we
mentally compute through reading 1, 2 or 3 characters we see it also works; for example a b c <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">\n</span></span></span>
works.
<!--l. 266--><p class="noindent" ><span 
class="cmbx-10">s[0] is a </span><br 
class="newline" /><span 
class="cmbx-10">s[1] is b </span><br 
class="newline" /><span 
class="cmbx-10">s[2] is c </span><br 
class="newline" /><span 
class="cmbx-10">s[3] is 0 </span><br 
class="newline" />
<!--l. 271--><p class="noindent" >Looks good.
<!--l. 273--><p class="noindent" >Here is the better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/better.c" > better.c&#x00A0;</a>
<!--l. 277--><p class="noindent" >But what if we get an empty line and the first characters is an EOF? It breaks. Another pesky bug in our
code. More specifically, we do not cater for an unexpected action, well at least in terms of the person that
coded the loop. Someone hitting control D (EOF) would be a likely occurrences, well a probabilistic
occurrence.
<!--l. 279--><p class="noindent" >OK. Let&#347; fix this boundary bug.
<div 
class="colorbox" id="colorbox7"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char</span><span 
class="cmtt-10">&#x00A0;s[MAX];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;MAX-1;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;((s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;getchar())</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;&#8217;\n&#8217;</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;break;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;s[i]</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;\0&#8217;;</span><br /><br /><br /></div></div>
<!--l. 300--><p class="noindent" >That works! Nice piece of code now. Looks like we are done.
<!--l. 302--><p class="noindent" >Here is the even better code. Try it out. <span 
class="cmbx-10">C code</span>:<a 
href="http://www.cs.dartmouth.edu/~campbell/cs50/evenbetter.c" > evenbetter.c&#x00A0;</a>
<!--l. 306--><p class="noindent" >We have removed and tested all the edge cases. The code handles all the edge cases nicely
now.
<!--l. 308--><p class="noindent" >// - where the first character is newline
<!--l. 310--><p class="noindent" >// - where the first character is EOF
<!--l. 312--><p class="noindent" >// - where there is one character
<!--l. 314--><p class="noindent" >// - where there are more characters input than the max size of the array
<!--l. 316--><p class="noindent" >// - where characters are entered terminated by a newline
<!--l. 318--><p class="noindent" >// - where there are characters entered terminated by a EOF (control D)
<!--l. 322--><p class="noindent" >Em...are we sure. There are other boundary problems that could lurk here. What happens if the array is
nearly full - does it work? What happens if the array is exactly full? Or over full - what happens if any of
these conditions occur followed by a newline. Are these boundary conditions catered for? We will leave you
to determine the answer to that question.
                                                                                  
                                                                                  
<!--l. 324--><p class="noindent" ><span 
class="cmbx-10">You get the idea. Bugs lurk at boundaries. Conversely, if code works at boundaries it is</span>
<span 
class="cmbx-10">likely to work elsewhere</span>
<!--l. 326--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-11000"></a>TIP: Test pre and post conditions</h3>
<!--l. 328--><p class="noindent" >It is always a good idea to test for pre and post conditions - that is before and after, respectively, some
program executes. For example, we have already used defensive program to check input values are with in
range - an example of pre-condition testing. Let&#347; look at another simple example out of [KP, 1999] that
computes the average of n elements in an array a[]. Closer inspection of the code reveals that there is a
problem is n is less than or equal to 0.
<div 
class="colorbox" id="colorbox8"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /></div></div>
<!--l. 355--><p class="noindent" >A natural question is what to do if someone calls avg() with n=0? An array of zero elements does not
make much sense but an average of 0 does. Should our code catch the division by zero? with an assert, or
abort, or complain or be silent? One reasonable approach is to just return 0 as the average if n is less than
or equal to zero. While the code is idiomatic in style we need to tweak it to test pre-condition, as shown
below - note: <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n</span></span></span>
<div 
class="colorbox" id="colorbox9"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sum;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;n</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;?</span><span 
class="cmtt-10">&#x00A0;0.0</span><span 
class="cmtt-10">&#x00A0;:</span><span 
class="cmtt-10">&#x00A0;sum/n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 384--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-12000"></a>TIP: Use asserts or in the case of TinySearch MY_ASSERT()</h3>
<!--l. 386--><p class="noindent" >We have used MY_ASSERT() macros in the development of TinySearch and in the unit testing code with
SHOULD_BE(); for example:
<div 
class="colorbox" id="colorbox10"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;dictionary_test.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DICTIONARY*</span><span 
class="cmtt-10">&#x00A0;dict</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;InitDictionary();</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d1;</span><span 
class="cmtt-10">&#x00A0;d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d1</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;1;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;*d2;</span><span 
class="cmtt-10">&#x00A0;d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;malloc(sizeof(int));</span><span 
class="cmtt-10">&#x00A0;*d2</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;2;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d1,</span><span 
class="cmtt-10">&#x00A0;"1");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;hash</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;DAdd(dict,</span><span 
class="cmtt-10">&#x00A0;d2,</span><span 
class="cmtt-10">&#x00A0;"2");</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;end</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]-&#x003E;next);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;start</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d1);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;data</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;(void*)d2);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;prev</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;dict-&#x003E;hash[0]);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;SHOULD_BE(dict-&#x003E;hash[0]-&#x003E;next-&#x003E;next</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;NULL);</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;\\</span><span 
class="cmtt-10">&#x00A0;Snippet</span><span 
class="cmtt-10">&#x00A0;from</span><span 
class="cmtt-10">&#x00A0;crawler.c</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;current_depth,</span><span 
class="cmtt-10">&#x00A0;max_depth;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;URLToBeVisited;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char**</span><span 
class="cmtt-10">&#x00A0;URLsLists;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;char*</span><span 
class="cmtt-10">&#x00A0;page;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;current_depth</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;MYASSERT(sscanf(argv[3],</span><span 
class="cmtt-10">&#x00A0;"%d",</span><span 
class="cmtt-10">&#x00A0;&amp;max_depth)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;1);</span><br /><br /><br /></div></div>
<!--l. 425--><p class="noindent" >C provides an assertion facility in assert.h useful for pre and post condition testing. Asserts are
usually used for unexpected failure where there is no clean way to recover the logic control. For
example our avg() function could include a different solution then n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003C;</span></span></span>= 0 using the assert
function:
<div 
class="colorbox" id="colorbox11"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;avg(double</span><span 
class="cmtt-10">&#x00A0;a[],</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;n)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;{</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;int</span><span 
class="cmtt-10">&#x00A0;i;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;double</span><span 
class="cmtt-10">&#x00A0;sume</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;assert(n</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;0);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0.0;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;(i</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;0;</span><span 
class="cmtt-10">&#x00A0;i</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;n;</span><span 
class="cmtt-10">&#x00A0;i++)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;+=</span><span 
class="cmtt-10">&#x00A0;a[i];</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;return</span><span 
class="cmtt-10">&#x00A0;sum</span><span 
class="cmtt-10">&#x00A0;/</span><span 
class="cmtt-10">&#x00A0;n;</span><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 456--><p class="noindent" >If the assertion is in fact violated it will cause an abort and standard message to be printed
out:
<!--l. 458--><p class="noindent" >Assertion failed: n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x003E;</span></span></span> 0, file avgtest.c, line 7 <br 
class="newline" />Abort(crash)<br 
class="newline" />
                                                                                  
                                                                                  
<!--l. 461--><p class="noindent" >Assertions are very useful in validating the expected properties of an interface or range of input
arguments.
<!--l. 464--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-13000"></a>TIP: Test for the unexpected: aka defensive programming</h3>
<!--l. 466--><p class="noindent" >Your crawler and indexer uses defensive programming for checking that the input arguments are logically
correct: e.g., that a path actually existed. But a useful technique when coding is to &#8220;expect the
unexpected&#8221; or code for the unexpected. Adding checks for n <span class="obeylines-h"><span class="verb"><span 
class="cmtt-10">&#x00A0;&#x003C;</span></span></span> 0 in avg() is an example. Another is
below:
<div 
class="colorbox" id="colorbox12"><div class="BVerbatimInput"><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003C;</span><span 
class="cmtt-10">&#x00A0;0</span><span 
class="cmtt-10">&#x00A0;||</span><span 
class="cmtt-10">&#x00A0;grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;</span><span 
class="cmtt-10">&#x00A0;100}</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*can&#8217;t</span><span 
class="cmtt-10">&#x00A0;happen,</span><span 
class="cmtt-10">&#x00A0;well</span><span 
class="cmtt-10">&#x00A0;possibly,</span><span 
class="cmtt-10">&#x00A0;at</span><span 
class="cmtt-10">&#x00A0;Dartmouth</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;?&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(grade</span><span 
class="cmtt-10">&#x00A0;&#x003E;=</span><span 
class="cmtt-10">&#x00A0;90)</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;letter</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;&#8217;A&#8217;;</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;else</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;....</span><br /><br /><br /></div></div>
<!--l. 488--><p class="noindent" >The CS50 automatic grading program - a snippet is shown above ;-) handles negative grades (I<img 
src="artoftesting0x.png" alt="v  "  class="acute" >e yet to
do that) and very large grades. If the unexpected happens the code returns a ? This is a good example of
defensive programming. In essence our programmer is coding against incorrect use or illegal data. Other
examples include:
<!--l. 493--><p class="noindent" >1) Out of range subscripts <br 
class="newline" />2) NULL pointers <br 
class="newline" />3) Divide by zero <br 
class="newline" />
<!--l. 498--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-14000"></a>TIP: Always check error returns from functions</h3>
<!--l. 500--><p class="noindent" >A really good programmer will always check the return status from functions, system calls, and libraries. If
you neglect to look at the return status then how do you know that the function really worked. If your
code assumes it did not fail but it did then the segfault or error will be hard to debug. Better to always
check the error status returned by functions.
<!--l. 506--><p class="noindent" >Another example from [KP, 1996].
<div 
class="colorbox" id="colorbox13"><div class="BVerbatimInput"><br /><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fp</span><span 
class="cmtt-10">&#x00A0;=</span><span 
class="cmtt-10">&#x00A0;fopen(outfile,</span><span 
class="cmtt-10">&#x00A0;&#8216;&#8216;w&#8217;&#8217;);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;while</span><span 
class="cmtt-10">&#x00A0;(some</span><span 
class="cmtt-10">&#x00A0;expression)</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;write</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;file*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;fprintf(fp,</span><span 
class="cmtt-10">&#x00A0;...);</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;if</span><span 
class="cmtt-10">&#x00A0;(fclose(fp)</span><span 
class="cmtt-10">&#x00A0;==</span><span 
class="cmtt-10">&#x00A0;EOF)</span><span 
class="cmtt-10">&#x00A0;{</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;check</span><span 
class="cmtt-10">&#x00A0;for</span><span 
class="cmtt-10">&#x00A0;errors</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;/*</span><span 
class="cmtt-10">&#x00A0;some</span><span 
class="cmtt-10">&#x00A0;output</span><span 
class="cmtt-10">&#x00A0;error</span><span 
class="cmtt-10">&#x00A0;occurred</span><span 
class="cmtt-10">&#x00A0;*/</span><br /><span 
class="cmtt-10">&#x00A0;</span><span 
class="cmtt-10">&#x00A0;}</span><br /><br /><br /></div></div>
<!--l. 527--><p class="noindent" >Output errors can be serious problem and if the file being written above fails and the error status not
checked on fprintf then the file data can be lost. But the check above will save you from removing the old
file if the new one was not written probably.
                                                                                  
                                                                                  
<!--l. 531--><p class="noindent" >
<h3 class="likesectionHead"><a 
 id="x1-15000"></a>TIP: Others useful things to do</h3>
<!--l. 533--><p class="noindent" >1) Test incrementally and build confidence in your code. <br 
class="newline" />2) Write unit tests that can be re-run once fixes or changes have been made. <br 
class="newline" />3) Write self-contained unit tests <br 
class="newline" />3.1) Test inputs and outputs.<br 
class="newline" />3.2) Test the dataflow through the program. <br 
class="newline" />3.3) Test all the execution paths through the program. <br 
class="newline" />3.4) Question: what environment do you need to set up to do 3.1-3.3<br 
class="newline" />4) Stress test the code; start simple and advance (test crawler at depth 1 .. 10 for example).<br 
class="newline" />5) Don&#8217;t implement new features if there are known bugs in the system.<br 
class="newline" />6) Test for portability: run code and tests on multiple machines/OSs.<br 
class="newline" />7) Before shipping code make sure that the test code ifdefs are off.<br 
class="newline" />
<!--l. 547--><p class="noindent" ><span 
class="cmbx-10">If you follow at least 50% of the tips in these notes you will write better code and it will</span>
<span 
class="cmbx-10">have considerably less bugs than if you did not apply these simple tips and strategy. Or your</span>
<span 
class="cmbx-10">money back.</span>
 
</body></html> 

                                                                                  


